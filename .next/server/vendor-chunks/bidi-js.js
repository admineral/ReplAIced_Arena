"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bidi-js";
exports.ids = ["vendor-chunks/bidi-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/bidi-js/dist/bidi.mjs":
/*!********************************************!*\
  !*** ./node_modules/bidi-js/dist/bidi.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction bidiFactory() {\nvar bidi = (function (exports) {\n\n  // Bidi character types data, auto generated\n  var DATA = {\n    \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n    \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n    \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n    \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n    \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n    \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n    \"B\": \"a,3,f+2,2v,690\",\n    \"S\": \"9,2,k\",\n    \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n    \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n    \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n    \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n    \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n    \"LRO\": \"6ct\",\n    \"RLO\": \"6cu\",\n    \"LRE\": \"6cq\",\n    \"RLE\": \"6cr\",\n    \"PDF\": \"6cs\",\n    \"LRI\": \"6ee\",\n    \"RLI\": \"6ef\",\n    \"FSI\": \"6eg\",\n    \"PDI\": \"6eh\"\n  };\n\n  var TYPES = {};\n  var TYPES_TO_NAMES = {};\n  TYPES.L = 1; //L is the default\n  TYPES_TO_NAMES[1] = 'L';\n  Object.keys(DATA).forEach(function (type, i) {\n    TYPES[type] = 1 << (i + 1);\n    TYPES_TO_NAMES[TYPES[type]] = type;\n  });\n  Object.freeze(TYPES);\n\n  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n  var map = null;\n\n  function parseData () {\n    if (!map) {\n      //const start = performance.now()\n      map = new Map();\n      var loop = function ( type ) {\n        if (DATA.hasOwnProperty(type)) {\n          var lastCode = 0;\n          DATA[type].split(',').forEach(function (range) {\n            var ref = range.split('+');\n            var skip = ref[0];\n            var step = ref[1];\n            skip = parseInt(skip, 36);\n            step = step ? parseInt(step, 36) : 0;\n            map.set(lastCode += skip, TYPES[type]);\n            for (var i = 0; i < step; i++) {\n              map.set(++lastCode, TYPES[type]);\n            }\n          });\n        }\n      };\n\n      for (var type in DATA) loop( type );\n      //console.log(`char types parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  /**\n   * @param {string} char\n   * @return {number}\n   */\n  function getBidiCharType (char) {\n    parseData();\n    return map.get(char.codePointAt(0)) || TYPES.L\n  }\n\n  function getBidiCharTypeName(char) {\n    return TYPES_TO_NAMES[getBidiCharType(char)]\n  }\n\n  // Bidi bracket pairs data, auto generated\n  var data$1 = {\n    \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n    \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n  };\n\n  /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */\n  function parseCharacterMap (encodedString, includeReverse) {\n    var radix = 36;\n    var lastCode = 0;\n    var map = new Map();\n    var reverseMap = includeReverse && new Map();\n    var prevPair;\n    encodedString.split(',').forEach(function visit(entry) {\n      if (entry.indexOf('+') !== -1) {\n        for (var i = +entry; i--;) {\n          visit(prevPair);\n        }\n      } else {\n        prevPair = entry;\n        var ref = entry.split('>');\n        var a = ref[0];\n        var b = ref[1];\n        a = String.fromCodePoint(lastCode += parseInt(a, radix));\n        b = String.fromCodePoint(lastCode += parseInt(b, radix));\n        map.set(a, b);\n        includeReverse && reverseMap.set(b, a);\n      }\n    });\n    return { map: map, reverseMap: reverseMap }\n  }\n\n  var openToClose, closeToOpen, canonical;\n\n  function parse$1 () {\n    if (!openToClose) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data$1.pairs, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      openToClose = map;\n      closeToOpen = reverseMap;\n      canonical = parseCharacterMap(data$1.canonical, false).map;\n      //console.log(`brackets parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function openingToClosingBracket (char) {\n    parse$1();\n    return openToClose.get(char) || null\n  }\n\n  function closingToOpeningBracket (char) {\n    parse$1();\n    return closeToOpen.get(char) || null\n  }\n\n  function getCanonicalBracket (char) {\n    parse$1();\n    return canonical.get(char) || null\n  }\n\n  // Local type aliases\n  var TYPE_L = TYPES.L;\n  var TYPE_R = TYPES.R;\n  var TYPE_EN = TYPES.EN;\n  var TYPE_ES = TYPES.ES;\n  var TYPE_ET = TYPES.ET;\n  var TYPE_AN = TYPES.AN;\n  var TYPE_CS = TYPES.CS;\n  var TYPE_B = TYPES.B;\n  var TYPE_S = TYPES.S;\n  var TYPE_ON = TYPES.ON;\n  var TYPE_BN = TYPES.BN;\n  var TYPE_NSM = TYPES.NSM;\n  var TYPE_AL = TYPES.AL;\n  var TYPE_LRO = TYPES.LRO;\n  var TYPE_RLO = TYPES.RLO;\n  var TYPE_LRE = TYPES.LRE;\n  var TYPE_RLE = TYPES.RLE;\n  var TYPE_PDF = TYPES.PDF;\n  var TYPE_LRI = TYPES.LRI;\n  var TYPE_RLI = TYPES.RLI;\n  var TYPE_FSI = TYPES.FSI;\n  var TYPE_PDI = TYPES.PDI;\n\n  /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */\n\n  /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */\n  function getEmbeddingLevels (string, baseDirection) {\n    var MAX_DEPTH = 125;\n\n    // Start by mapping all characters to their unicode type, as a bitmask integer\n    var charTypes = new Uint32Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      charTypes[i] = getBidiCharType(string[i]);\n    }\n\n    var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n    function changeCharType(i, type) {\n      var oldType = charTypes[i];\n      charTypes[i] = type;\n      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n      if (oldType & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n      }\n      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n      if (type & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n      }\n    }\n\n    var embedLevels = new Uint8Array(string.length);\n    var isolationPairs = new Map(); //init->pdi and pdi->init\n\n    // === 3.3.1 The Paragraph Level ===\n    // 3.3.1 P1: Split the text into paragraphs\n    var paragraphs = []; // [{start, end, level}, ...]\n    var paragraph = null;\n    for (var i$1 = 0; i$1 < string.length; i$1++) {\n      if (!paragraph) {\n        paragraphs.push(paragraph = {\n          start: i$1,\n          end: string.length - 1,\n          // 3.3.1 P2-P3: Determine the paragraph level\n          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n        });\n      }\n      if (charTypes[i$1] & TYPE_B) {\n        paragraph.end = i$1;\n        paragraph = null;\n      }\n    }\n\n    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n    // Everything from here on will operate per paragraph.\n    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n      paragraph = paragraphs[paraIdx];\n      var statusStack = [{\n        _level: paragraph.level,\n        _override: 0, //0=neutral, 1=L, 2=R\n        _isolate: 0 //bool\n      }];\n      var stackTop = (void 0);\n      var overflowIsolateCount = 0;\n      var overflowEmbeddingCount = 0;\n      var validIsolateCount = 0;\n      charTypeCounts.clear();\n\n      // === 3.3.2 Explicit Levels and Directions ===\n      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n        var charType = charTypes[i$2];\n        stackTop = statusStack[statusStack.length - 1];\n\n        // Set initial counts\n        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n        if (charType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n\n        // Explicit Embeddings: 3.3.2 X2 - X3\n        if (charType & FORMATTING_TYPES) { //prefilter all formatters\n          if (charType & (TYPE_RLE | TYPE_LRE)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level,\n                _override: 0,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Explicit Overrides: 3.3.2 X4 - X5\n          else if (charType & (TYPE_RLO | TYPE_LRO)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level$1,\n                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Isolates: 3.3.2 X5a - X5c\n          else if (charType & ISOLATE_INIT_TYPES) {\n            // X5c - FSI becomes either RLI or LRI\n            if (charType & TYPE_FSI) {\n              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n            }\n\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n              validIsolateCount++;\n              statusStack.push({\n                _level: level$2,\n                _override: 0,\n                _isolate: 1,\n                _isolInitIndex: i$2\n              });\n            } else {\n              overflowIsolateCount++;\n            }\n          }\n\n          // Terminating Isolates: 3.3.2 X6a\n          else if (charType & TYPE_PDI) {\n            if (overflowIsolateCount > 0) {\n              overflowIsolateCount--;\n            } else if (validIsolateCount > 0) {\n              overflowEmbeddingCount = 0;\n              while (!statusStack[statusStack.length - 1]._isolate) {\n                statusStack.pop();\n              }\n              // Add to isolation pairs bidirectional mapping:\n              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n              if (isolInitIndex != null) {\n                isolationPairs.set(isolInitIndex, i$2);\n                isolationPairs.set(i$2, isolInitIndex);\n              }\n              statusStack.pop();\n              validIsolateCount--;\n            }\n            stackTop = statusStack[statusStack.length - 1];\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n\n\n          // Terminating Embeddings and Overrides: 3.3.2 X7\n          else if (charType & TYPE_PDF) {\n            if (overflowIsolateCount === 0) {\n              if (overflowEmbeddingCount > 0) {\n                overflowEmbeddingCount--;\n              } else if (!stackTop._isolate && statusStack.length > 1) {\n                statusStack.pop();\n                stackTop = statusStack[statusStack.length - 1];\n              }\n            }\n            embedLevels[i$2] = stackTop._level; // 5.2\n          }\n\n          // End of Paragraph: 3.3.2 X8\n          else if (charType & TYPE_B) {\n            embedLevels[i$2] = paragraph.level;\n          }\n        }\n\n        // Non-formatting characters: 3.3.2 X6\n        else {\n          embedLevels[i$2] = stackTop._level;\n          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n          if (stackTop._override && charType !== TYPE_BN) {\n            changeCharType(i$2, stackTop._override);\n          }\n        }\n      }\n\n      // === 3.3.3 Preparations for Implicit Processing ===\n\n      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n      // easily ignore them all from here on out.\n\n      // 3.3.3 X10\n      // Compute the set of isolating run sequences as specified by BD13\n      var levelRuns = [];\n      var currentRun = null;\n      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n        var charType$1 = charTypes[i$3];\n        if (!(charType$1 & BN_LIKE_TYPES)) {\n          var lvl = embedLevels[i$3];\n          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n          var isPDI = charType$1 === TYPE_PDI;\n          if (currentRun && lvl === currentRun._level) {\n            currentRun._end = i$3;\n            currentRun._endsWithIsolInit = isIsolInit;\n          } else {\n            levelRuns.push(currentRun = {\n              _start: i$3,\n              _end: i$3,\n              _level: lvl,\n              _startsWithPDI: isPDI,\n              _endsWithIsolInit: isIsolInit\n            });\n          }\n        }\n      }\n      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n        var run = levelRuns[runIdx];\n        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n          var seqRuns = [currentRun = run];\n          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n              if (levelRuns[i$4]._start === pdiIndex) {\n                seqRuns.push(currentRun = levelRuns[i$4]);\n                break\n              }\n            }\n          }\n          // build flat list of indices across all runs:\n          var seqIndices = [];\n          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n            var run$1 = seqRuns[i$5];\n            for (var j = run$1._start; j <= run$1._end; j++) {\n              seqIndices.push(j);\n            }\n          }\n          // determine the sos/eos types:\n          var firstLevel = embedLevels[seqIndices[0]];\n          var prevLevel = paragraph.level;\n          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n              prevLevel = embedLevels[i$6];\n              break\n            }\n          }\n          var lastIndex = seqIndices[seqIndices.length - 1];\n          var lastLevel = embedLevels[lastIndex];\n          var nextLevel = paragraph.level;\n          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                nextLevel = embedLevels[i$7];\n                break\n              }\n            }\n          }\n          isolatingRunSeqs.push({\n            _seqIndices: seqIndices,\n            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n          });\n        }\n      }\n\n      // The next steps are done per isolating run sequence\n      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n        var ref = isolatingRunSeqs[seqIdx];\n        var seqIndices$1 = ref._seqIndices;\n        var sosType = ref._sosType;\n        var eosType = ref._eosType;\n        /**\n         * All the level runs in an isolating run sequence have the same embedding level.\n         * \n         * DO NOT change any `embedLevels[i]` within the current scope.\n         */\n        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n        // === 3.3.4 Resolving Weak Types ===\n\n        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n        if (charTypeCounts.get(TYPE_NSM)) {\n          for (var si = 0; si < seqIndices$1.length; si++) {\n            var i$8 = seqIndices$1[si];\n            if (charTypes[i$8] & TYPE_NSM) {\n              var prevType = sosType;\n              for (var sj = si - 1; sj >= 0; sj--) {\n                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                  prevType = charTypes[seqIndices$1[sj]];\n                  break\n                }\n              }\n              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n            }\n          }\n        }\n\n        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n        // is found. If an AL is found, change the type of the European number to Arabic number.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n            var i$9 = seqIndices$1[si$1];\n            if (charTypes[i$9] & TYPE_EN) {\n              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                if (prevCharType & STRONG_TYPES) {\n                  if (prevCharType === TYPE_AL) {\n                    changeCharType(i$9, TYPE_AN);\n                  }\n                  break\n                }\n              }\n            }\n          }\n        }\n\n        // W3. Change all ALs to R\n        if (charTypeCounts.get(TYPE_AL)) {\n          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n            var i$10 = seqIndices$1[si$2];\n            if (charTypes[i$10] & TYPE_AL) {\n              changeCharType(i$10, TYPE_R);\n            }\n          }\n        }\n\n        // W4. A single European separator between two European numbers changes to a European number. A single common\n        // separator between two numbers of the same type changes to that type.\n        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n            var i$11 = seqIndices$1[si$3];\n            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n              var prevType$1 = 0, nextType = 0;\n              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                prevType$1 = charTypes[seqIndices$1[sj$2]];\n                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                nextType = charTypes[seqIndices$1[sj$3]];\n                if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                changeCharType(i$11, prevType$1);\n              }\n            }\n          }\n        }\n\n        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n            var i$12 = seqIndices$1[si$4];\n            if (charTypes[i$12] & TYPE_EN) {\n              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                changeCharType(seqIndices$1[sj$4], TYPE_EN);\n              }\n              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                  changeCharType(seqIndices$1[si$4], TYPE_EN);\n                }\n              }\n            }\n          }\n        }\n\n        // W6. Otherwise, separators and terminators change to Other Neutral.\n        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n            var i$13 = seqIndices$1[si$5];\n            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n              changeCharType(i$13, TYPE_ON);\n              // 5.2 transform adjacent BNs too:\n              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                changeCharType(seqIndices$1[sj$5], TYPE_ON);\n              }\n              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                changeCharType(seqIndices$1[sj$6], TYPE_ON);\n              }\n            }\n          }\n        }\n\n        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n        // is found. If an L is found, then change the type of the European number to L.\n        // NOTE: implemented in single forward pass for efficiency\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n            var i$14 = seqIndices$1[si$6];\n            var type = charTypes[i$14];\n            if (type & TYPE_EN) {\n              if (prevStrongType === TYPE_L) {\n                changeCharType(i$14, TYPE_L);\n              }\n            } else if (type & STRONG_TYPES) {\n              prevStrongType = type;\n            }\n          }\n        }\n\n        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n          // types EN and AN are treated as R.\n          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n          // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n          var bracketPairs = [];\n          {\n            var openerStack = [];\n            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n              // NOTE: for any potential bracket character we also test that it still carries a NI\n              // type, as that may have been changed earlier. This doesn't seem to be explicitly\n              // called out in the spec, but is required for passage of certain tests.\n              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                var char = string[seqIndices$1[si$7]];\n                var oppositeBracket = (void 0);\n                // Opening bracket\n                if (openingToClosingBracket(char) !== null) {\n                  if (openerStack.length < 63) {\n                    openerStack.push({ char: char, seqIndex: si$7 });\n                  } else {\n                    break\n                  }\n                }\n                // Closing bracket\n                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                    var stackChar = openerStack[stackIdx].char;\n                    if (stackChar === oppositeBracket ||\n                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                    ) {\n                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                      openerStack.length = stackIdx; //pop the matching bracket and all following\n                      break\n                    }\n                  }\n                }\n              }\n            }\n            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n          }\n          // * For each bracket-pair element in the list of pairs of text positions\n          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n            var ref$1 = bracketPairs[pairIdx];\n            var openSeqIdx = ref$1[0];\n            var closeSeqIdx = ref$1[1];\n            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n            // brackets in the pair to match the embedding direction.\n            var foundStrongType = false;\n            var useStrongType = 0;\n            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n              var i$15 = seqIndices$1[si$8];\n              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                foundStrongType = true;\n                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                if (lr === embedDirection) {\n                  useStrongType = lr;\n                  break\n                }\n              }\n            }\n            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n            // for an established context with a preceding strong type by checking backwards before the opening paired\n            // bracket until the first strong type (L, R, or sos) is found.\n            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n            //    set the type for both brackets in the pair to that direction.\n            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n            if (foundStrongType && !useStrongType) {\n              useStrongType = sosType;\n              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                var i$16 = seqIndices$1[si$9];\n                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr$1 !== embedDirection) {\n                    useStrongType = lr$1;\n                  } else {\n                    useStrongType = embedDirection;\n                  }\n                  break\n                }\n              }\n            }\n            if (useStrongType) {\n              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n              // * Any number of characters that had original bidirectional character type NSM prior to the application\n              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n              // the type of their preceding bracket.\n              if (useStrongType !== embedDirection) {\n                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$10]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType !== embedDirection) {\n                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$11]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n          // same direction.\n          // N2. Any remaining NIs take the embedding direction.\n          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n              var niRunStart = si$12, niRunEnd = si$12;\n              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n              for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                } else {\n                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              var nextType$1 = eosType;\n              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                  niRunEnd = si2$1;\n                } else {\n                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n              }\n              si$12 = niRunEnd;\n            }\n          }\n        }\n      }\n\n      // === 3.3.6 Resolving Implicit Levels ===\n\n      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n        var level$3 = embedLevels[i$17];\n        var type$1 = charTypes[i$17];\n        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        if (level$3 & 1) {\n          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n            embedLevels[i$17]++;\n          }\n        }\n          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n        // and those of type AN or EN go up two levels.\n        else {\n          if (type$1 & TYPE_R) {\n            embedLevels[i$17]++;\n          } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n            embedLevels[i$17] += 2;\n          }\n        }\n\n        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n        // and otherwise to the base level.\n        if (type$1 & BN_LIKE_TYPES) {\n          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n        }\n\n        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n            embedLevels[j$1] = paragraph.level;\n          }\n        }\n      }\n    }\n\n    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n    // according to section 3.4 Reordering Resolved Levels\n    return {\n      levels: embedLevels,\n      paragraphs: paragraphs\n    }\n\n    function determineAutoEmbedLevel (start, isFSI) {\n      // 3.3.1 P2 - P3\n      for (var i = start; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & (TYPE_R | TYPE_AL)) {\n          return 1\n        }\n        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n          return 0\n        }\n        if (charType & ISOLATE_INIT_TYPES) {\n          var pdi = indexOfMatchingPDI(i);\n          i = pdi === -1 ? string.length : pdi;\n        }\n      }\n      return 0\n    }\n\n    function indexOfMatchingPDI (isolateStart) {\n      // 3.1.2 BD9\n      var isolationLevel = 1;\n      for (var i = isolateStart + 1; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & TYPE_B) {\n          break\n        }\n        if (charType & TYPE_PDI) {\n          if (--isolationLevel === 0) {\n            return i\n          }\n        } else if (charType & ISOLATE_INIT_TYPES) {\n          isolationLevel++;\n        }\n      }\n      return -1\n    }\n  }\n\n  // Bidi mirrored chars data, auto generated\n  var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n  var mirrorMap;\n\n  function parse () {\n    if (!mirrorMap) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      // Combine both maps into one\n      reverseMap.forEach(function (value, key) {\n        map.set(key, value);\n      });\n      mirrorMap = map;\n      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function getMirroredCharacter (char) {\n    parse();\n    return mirrorMap.get(char) || null\n  }\n\n  /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */\n  function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var map = new Map();\n    for (var i = start; i <= end; i++) {\n      if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n        var mirror = getMirroredCharacter(string[i]);\n        if (mirror !== null) {\n          map.set(i, mirror);\n        }\n      }\n    }\n    return map\n  }\n\n  /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */\n  function getReorderSegments(string, embeddingLevelsResult, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var segments = [];\n    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n      var lineStart = Math.max(start, paragraph.start);\n      var lineEnd = Math.min(end, paragraph.end);\n      if (lineStart < lineEnd) {\n        // Local slice for mutation\n        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n        // end of the line to the paragraph level.\n        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n          lineLevels[i] = paragraph.level;\n        }\n\n        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n        var maxLevel = paragraph.level;\n        var minOddLevel = Infinity;\n        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n          var level = lineLevels[i$1];\n          if (level > maxLevel) { maxLevel = level; }\n          if (level < minOddLevel) { minOddLevel = level | 1; }\n        }\n        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n            if (lineLevels[i$2] >= lvl) {\n              var segStart = i$2;\n              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                i$2++;\n              }\n              if (i$2 > segStart) {\n                segments.push([segStart + lineStart, i$2 + lineStart]);\n              }\n            }\n          }\n        }\n      }\n    });\n    return segments\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */\n  function getReorderedString(string, embedLevelsResult, start, end) {\n    var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n    var chars = [].concat( string );\n    indices.forEach(function (charIndex, i) {\n      chars[i] = (\n        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n      ) || string[charIndex];\n    });\n    return chars.join('')\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */\n  function getReorderedIndices(string, embedLevelsResult, start, end) {\n    var segments = getReorderSegments(string, embedLevelsResult, start, end);\n    // Fill an array with indices\n    var indices = [];\n    for (var i = 0; i < string.length; i++) {\n      indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(function (ref) {\n      var start = ref[0];\n      var end = ref[1];\n\n      var slice = indices.slice(start, end + 1);\n      for (var i = slice.length; i--;) {\n        indices[end - i] = slice[i];\n      }\n    });\n    return indices\n  }\n\n  exports.closingToOpeningBracket = closingToOpeningBracket;\n  exports.getBidiCharType = getBidiCharType;\n  exports.getBidiCharTypeName = getBidiCharTypeName;\n  exports.getCanonicalBracket = getCanonicalBracket;\n  exports.getEmbeddingLevels = getEmbeddingLevels;\n  exports.getMirroredCharacter = getMirroredCharacter;\n  exports.getMirroredCharactersMap = getMirroredCharactersMap;\n  exports.getReorderSegments = getReorderSegments;\n  exports.getReorderedIndices = getReorderedIndices;\n  exports.getReorderedString = getReorderedString;\n  exports.openingToClosingBracket = openingToClosingBracket;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn bidi}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bidiFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlkaS1qcy9kaXN0L2JpZGkubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QVcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LW1hemUtYXBwLy4vbm9kZV9tb2R1bGVzL2JpZGktanMvZGlzdC9iaWRpLm1qcz9jZGZlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGJpZGlGYWN0b3J5KCkge1xudmFyIGJpZGkgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAvLyBCaWRpIGNoYXJhY3RlciB0eXBlcyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICB2YXIgREFUQSA9IHtcbiAgICBcIlJcIjogXCIxM2ssMWEsMiwzLDMsMisxaixjaCsxNixhKzEsNSsyLDIrbiw1LGEsNCw2KzE2LDQrMyxoKzFiLDRtbywxNzlxLDIrOSwyKzExLDJpOSs3eSwyKzY4LDQsMys0LDUrMTMsNCszLDIrNGssMysyOSw4K2NmLDF0Kzd6LHcrMTcsMyszbSwxdCszeiwxNm8xKzVyLDgrMzAsOCttYywyOSsxciwyOSs0diw3NSs3M1wiLFxuICAgIFwiRU5cIjogXCIxYys5LDNkKzEsNiwxODcrOSw1MTMsNCs1LDcrOSxzZitqLDE3NWgrOSxxdytxLDE2MWYrMWQsNHh0K2EsMjVpKzlcIixcbiAgICBcIkVTXCI6IFwiMTcsMiw2ZHArMSxmKzEsYXYsMTZ2cixteCsxLDRvLDJcIixcbiAgICBcIkVUXCI6IFwieisyLDNoKzMsYisxLHltLDNlKzEsMm8scDQrMSw4LDZ1LDdjLGc2LDF3YywxbjkrNCwzMCsxYiwybiw2ZCxxaHgrMSxoMG0sYSsxLDQ5KzIsNjMrMSw0KzEsNmJiKzMsMTJqalwiLFxuICAgIFwiQU5cIjogXCIxNm8rNSwyais5LDIrMSwzNSxlZCwxZmYyKzksODcrdVwiLFxuICAgIFwiQ1NcIjogXCIxOCwyKzEsYiwydSwxMmssNTV2LGwsMTd2MCwyLDMsNTMsMisxLGJcIixcbiAgICBcIkJcIjogXCJhLDMsZisyLDJ2LDY5MFwiLFxuICAgIFwiU1wiOiBcIjksMixrXCIsXG4gICAgXCJXU1wiOiBcImMsayw0ZjQsMXZrK2EsdSwxaiwzMzVcIixcbiAgICBcIk9OXCI6IFwieCsxLDQrNCxoKzUscis1LHIrMyx6LDUrMywyKzEsMisxLDUsMisyLDMrNCxvLHcsY2krMSw4K2QsMytkLDYrOCwyK2csMzkrMSw5LDYrMSwyLDMzLGI4LDMrMSwzYysxLDcrMSw1cixiLDdoKzMsc2ErNSwyLDNpKzYsamcrMyx1cis5LDJ2LGlqKzEsOWcrOSw3K2EsOG0sNCsxLDQ5K3gsMTR1LDIrMixjKzIsZSsyLGUrMixlKzEsaStuLGUrZSwyK3AsdSsyLGUrMiwzNisxLDIrMywyKzEsYiwyKzIsNis1LDIsMiwyLGgrMSw1KzQsNiszLDMrZiwxNisyLDUrM2wsMys4MSwxeStwLDIrNDAscSthLG0rMTMsMnIrY2gsMis5ZSw3NStoZiwzK3YsMisydyw2ZSs1LGYrNiw3NSsyYSwxYStwLDIrMmcsZCs1eCxyK2IsNiszLDQrbyxnLDYrMSw2KzIsMmsrMSw0LDJqLDVoK3osMW0rMSwxZStmLHQrMiwxZitlLGQrMyw0byszLDJzKzEsdyw1MzUrMXIsaDNsKzFpLDkzKzIsMnMsYisxLDNsK3gsMnYsNGcrMywyMSszLGt6KzEsZzV2KzEsNWEsais5LG4rdiwyLDMsMis4LDIrMSwzKzIsMiwzLDQ2KzEsNCs0LGgrNSxyKzUscithLDNoKzIsNCs2LGIrNCw3OCwxcisyNCw0K2MsNCwxaGIsZXkrNiwxMDMraiwxNmorYywxdXgrNyw1K2csZnNoLGpkcSsxdCw0LDU3KzJlLHAxLDFtLDFtLDFtLDFtLDRrdCsxLDdqKzE3LDUrMnIsZCtlLDMrZSwyK2UsMisxMCxtKzQsdywxbis1LDFxLDR6KzUsNGIrcmIsOStjLDQrYyw0KzM3LGQrMmcsOCtiLGwrYiw1KzFqLDkrOSw3KzEzLDkrdCwzKzEsMjcrM2MsMisyOSwyKzNxLGQrZCwzKzQsNCsyLDYrNixhK28sOCs2LGErMixlKzYsMTYrNDIsMisxaVwiLFxuICAgIFwiQk5cIjogXCIwKzgsNitkLDJzKzUsMitwLGUsNG05LDFrdCsyLDJiKzUsNSs1LDE3cTkrdiw3ayw2cCs4LDYrMSwxMTlkKzMsNDQwKzcsOTZzKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzc1LDZwKzJyeiwxYmVuKzEsMWVrZisxLDFla2YrMVwiLFxuICAgIFwiTlNNXCI6IFwibGMrMzMsN28rNiw3YysxOCwyLDIrMSwyKzEsMiwyMSthLDFkK2ssaCwydSs2LDMrNSwzKzEsMiszLDEwLHYrcSwyaythLDFuKzgsYSxwKzMsMis4LDIrMiwyKzQsMTgrMiwzYytlLDIrdiwxaywyLDUrNyw1LDQrNixiKzEsdSwxbiw1KzMsOSxsKzEsciwzKzEsMW0sNSsxLDUrMSwzKzIsNCx2KzEsNCxjKzEsMW0sNSs0LDIrMSw1LGwrMSxuKzUsMiwxbiwzLDIrMyw5LDgrMSxjKzEsdiwxcSxkLDFmLDQsMW0rMiw2KzIsMiszLDgrMSxjKzEsdSwxbixnKzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2csMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsazErdywyZGIrMiwzeSwycCt2LGZmKzMsMzArMSxuOXgrMywyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZixyMiw2Yiw0Nis0LDFhZisyLDIrMSw2KzMsMTUrMiw1LDRtKzEsZnkrMyxhcysxLDRhK2EsNHgsMWorZSwxbCsyLDFlKzMsMysxLDF5KzIsMTErNCwyKzcsMXIsZCsxLDFoKzgsYiszLDMsMm8rMiwzLDIrMSw3LDRoLDQrNyxtKzEsMW0rMSw0LDEyKzYsNCs0LDVnKzcsMysyLDIsbywyZCs1LDIsNSsxLDIrMSw2biszLDcrMSwyKzEscysxLDJlKzcsMywyKzEsMnosMiwzKzUsMiwydSsyLDMrMywyKzQsNzgrOCwyKzEsNzUrMSwyLDUsNDErMywzKzEsNSx4KzUsMysxLDE1KzUsMyszLDksYSs1LDMrMiwxYitjLDIrMSxiYis2LDIrNSwyZCtsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSxmMGMrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsNDN0KzIsaSs3LDMrNix2KzMsNDUrMiwxajArMWksNSsxZCw5LGYsbis0LDIrZSwxMXQrNiwyK2csMys2LDIrMSwyKzQsN2ErNixjNiszLDE1dCs2LDMyKzYsZ3poeSs2blwiLFxuICAgIFwiQUxcIjogXCIxNncsMywyLGUrMWIseisyLDIrMnMsZysxLDgrMSxiK20sMit0LHMrMmksYytlLDRoK2YsMWQrMWUsMWJ3ZStkcCwzKzN6LHgrYywyKzEsMzUrM3ksMnJtK3osNSs3LGIrNSxkdCtsLGMrdSwxN25sKzI3LDF0KzI3LDR4KzZuLDMrZFwiLFxuICAgIFwiTFJPXCI6IFwiNmN0XCIsXG4gICAgXCJSTE9cIjogXCI2Y3VcIixcbiAgICBcIkxSRVwiOiBcIjZjcVwiLFxuICAgIFwiUkxFXCI6IFwiNmNyXCIsXG4gICAgXCJQREZcIjogXCI2Y3NcIixcbiAgICBcIkxSSVwiOiBcIjZlZVwiLFxuICAgIFwiUkxJXCI6IFwiNmVmXCIsXG4gICAgXCJGU0lcIjogXCI2ZWdcIixcbiAgICBcIlBESVwiOiBcIjZlaFwiXG4gIH07XG5cbiAgdmFyIFRZUEVTID0ge307XG4gIHZhciBUWVBFU19UT19OQU1FUyA9IHt9O1xuICBUWVBFUy5MID0gMTsgLy9MIGlzIHRoZSBkZWZhdWx0XG4gIFRZUEVTX1RPX05BTUVTWzFdID0gJ0wnO1xuICBPYmplY3Qua2V5cyhEQVRBKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgVFlQRVNbdHlwZV0gPSAxIDw8IChpICsgMSk7XG4gICAgVFlQRVNfVE9fTkFNRVNbVFlQRVNbdHlwZV1dID0gdHlwZTtcbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoVFlQRVMpO1xuXG4gIHZhciBJU09MQVRFX0lOSVRfVFlQRVMgPSBUWVBFUy5MUkkgfCBUWVBFUy5STEkgfCBUWVBFUy5GU0k7XG4gIHZhciBTVFJPTkdfVFlQRVMgPSBUWVBFUy5MIHwgVFlQRVMuUiB8IFRZUEVTLkFMO1xuICB2YXIgTkVVVFJBTF9JU09MQVRFX1RZUEVTID0gVFlQRVMuQiB8IFRZUEVTLlMgfCBUWVBFUy5XUyB8IFRZUEVTLk9OIHwgVFlQRVMuRlNJIHwgVFlQRVMuTFJJIHwgVFlQRVMuUkxJIHwgVFlQRVMuUERJO1xuICB2YXIgQk5fTElLRV9UWVBFUyA9IFRZUEVTLkJOIHwgVFlQRVMuUkxFIHwgVFlQRVMuTFJFIHwgVFlQRVMuUkxPIHwgVFlQRVMuTFJPIHwgVFlQRVMuUERGO1xuICB2YXIgVFJBSUxJTkdfVFlQRVMgPSBUWVBFUy5TIHwgVFlQRVMuV1MgfCBUWVBFUy5CIHwgSVNPTEFURV9JTklUX1RZUEVTIHwgVFlQRVMuUERJIHwgQk5fTElLRV9UWVBFUztcblxuICB2YXIgbWFwID0gbnVsbDtcblxuICBmdW5jdGlvbiBwYXJzZURhdGEgKCkge1xuICAgIGlmICghbWFwKSB7XG4gICAgICAvL2NvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCB0eXBlICkge1xuICAgICAgICBpZiAoREFUQS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgIHZhciBsYXN0Q29kZSA9IDA7XG4gICAgICAgICAgREFUQVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gcmFuZ2Uuc3BsaXQoJysnKTtcbiAgICAgICAgICAgIHZhciBza2lwID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSByZWZbMV07XG4gICAgICAgICAgICBza2lwID0gcGFyc2VJbnQoc2tpcCwgMzYpO1xuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPyBwYXJzZUludChzdGVwLCAzNikgOiAwO1xuICAgICAgICAgICAgbWFwLnNldChsYXN0Q29kZSArPSBza2lwLCBUWVBFU1t0eXBlXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXA7IGkrKykge1xuICAgICAgICAgICAgICBtYXAuc2V0KCsrbGFzdENvZGUsIFRZUEVTW3R5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgdHlwZSBpbiBEQVRBKSBsb29wKCB0eXBlICk7XG4gICAgICAvL2NvbnNvbGUubG9nKGBjaGFyIHR5cGVzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCaWRpQ2hhclR5cGUgKGNoYXIpIHtcbiAgICBwYXJzZURhdGEoKTtcbiAgICByZXR1cm4gbWFwLmdldChjaGFyLmNvZGVQb2ludEF0KDApKSB8fCBUWVBFUy5MXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaWRpQ2hhclR5cGVOYW1lKGNoYXIpIHtcbiAgICByZXR1cm4gVFlQRVNfVE9fTkFNRVNbZ2V0QmlkaUNoYXJUeXBlKGNoYXIpXVxuICB9XG5cbiAgLy8gQmlkaSBicmFja2V0IHBhaXJzIGRhdGEsIGF1dG8gZ2VuZXJhdGVkXG4gIHZhciBkYXRhJDEgPSB7XG4gICAgXCJwYWlyc1wiOiBcIjE0PjEsMWU+Mix1PjIsMnd0PjEsMT4xLDFnZT4xLDF3cD4xLDFqPjEsZj4xLGhtPjEsMT4xLHU+MSx1Nj4xLDE+MSwrNSwyOD4xLHc+MSwxPjEsKzMsYjg+MSwxPjEsKzMsMT4zLC0xPi0xLDM+MSwxPjEsKzIsMXM+MSwxPjEseD4xLHRoPjEsMT4xLCsyLGRiPjEsMT4xLCszLDM+MSwxPjEsKzIsMTRxbT4xLDE+MSwrMSw0cT4xLDFlPjIsdT4yLDI+MSwrMVwiLFxuICAgIFwiY2Fub25pY2FsXCI6IFwiNmYxPi02ZHgsNmR5Pi02ZHgsNmVjPi02ZWQsNmVlPi02ZWQsNnd3PjJqaiwtMmppPjJqaiwxNHI0Pi0xZTdsLDFlN20+LTFlN2wsMWU3bT4tMWU1YywxZTVkPi0xZTViLDFlNWM+LTE0cXgsMTRxeT4tMTRxeCwxNHZuPi0xZWNnLDFlY2g+LTFlY2csMWVkdT4tMWVjZywxZWNpPi0xZWNnLDFlZGE+LTFlY2csMWVjaT4tMWVjZywxZWNpPi0xNjhxLDE2OHI+LTE2OHEsMTY4cz4tMTR5ZSwxNHlmPi0xNHllXCJcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuIHN0cmluZyB0aGF0IGhvbGRzIGVuY29kZWQgY29kZXBvaW50IG1hcHBpbmdzLCBlLmcuIGZvciBicmFja2V0IHBhaXJzIG9yXG4gICAqIG1pcnJvcmluZyBjaGFyYWN0ZXJzLCBhcyBlbmNvZGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGVCaWRpRGF0YS5qcy4gUmV0dXJucyBhbiBvYmplY3RcbiAgICogaG9sZGluZyB0aGUgYG1hcGAsIGFuZCBvcHRpb25hbGx5IGEgYHJldmVyc2VNYXBgIGlmIGBpbmNsdWRlUmV2ZXJzZTp0cnVlYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kZWRTdHJpbmdcbiAgICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlUmV2ZXJzZSAtIHRydWUgaWYgeW91IHdhbnQgcmV2ZXJzZU1hcCBpbiB0aGUgb3V0cHV0XG4gICAqIEByZXR1cm4ge3ttYXA6IE1hcDxudW1iZXIsIG51bWJlcj4sIHJldmVyc2VNYXA/OiBNYXA8bnVtYmVyLCBudW1iZXI+fX1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyTWFwIChlbmNvZGVkU3RyaW5nLCBpbmNsdWRlUmV2ZXJzZSkge1xuICAgIHZhciByYWRpeCA9IDM2O1xuICAgIHZhciBsYXN0Q29kZSA9IDA7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgcmV2ZXJzZU1hcCA9IGluY2x1ZGVSZXZlcnNlICYmIG5ldyBNYXAoKTtcbiAgICB2YXIgcHJldlBhaXI7XG4gICAgZW5jb2RlZFN0cmluZy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gdmlzaXQoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5pbmRleE9mKCcrJykgIT09IC0xKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSArZW50cnk7IGktLTspIHtcbiAgICAgICAgICB2aXNpdChwcmV2UGFpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZQYWlyID0gZW50cnk7XG4gICAgICAgIHZhciByZWYgPSBlbnRyeS5zcGxpdCgnPicpO1xuICAgICAgICB2YXIgYSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMV07XG4gICAgICAgIGEgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChsYXN0Q29kZSArPSBwYXJzZUludChhLCByYWRpeCkpO1xuICAgICAgICBiID0gU3RyaW5nLmZyb21Db2RlUG9pbnQobGFzdENvZGUgKz0gcGFyc2VJbnQoYiwgcmFkaXgpKTtcbiAgICAgICAgbWFwLnNldChhLCBiKTtcbiAgICAgICAgaW5jbHVkZVJldmVyc2UgJiYgcmV2ZXJzZU1hcC5zZXQoYiwgYSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgbWFwOiBtYXAsIHJldmVyc2VNYXA6IHJldmVyc2VNYXAgfVxuICB9XG5cbiAgdmFyIG9wZW5Ub0Nsb3NlLCBjbG9zZVRvT3BlbiwgY2Fub25pY2FsO1xuXG4gIGZ1bmN0aW9uIHBhcnNlJDEgKCkge1xuICAgIGlmICghb3BlblRvQ2xvc2UpIHtcbiAgICAgIC8vY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgdmFyIHJlZiA9IHBhcnNlQ2hhcmFjdGVyTWFwKGRhdGEkMS5wYWlycywgdHJ1ZSk7XG4gICAgICB2YXIgbWFwID0gcmVmLm1hcDtcbiAgICAgIHZhciByZXZlcnNlTWFwID0gcmVmLnJldmVyc2VNYXA7XG4gICAgICBvcGVuVG9DbG9zZSA9IG1hcDtcbiAgICAgIGNsb3NlVG9PcGVuID0gcmV2ZXJzZU1hcDtcbiAgICAgIGNhbm9uaWNhbCA9IHBhcnNlQ2hhcmFjdGVyTWFwKGRhdGEkMS5jYW5vbmljYWwsIGZhbHNlKS5tYXA7XG4gICAgICAvL2NvbnNvbGUubG9nKGBicmFja2V0cyBwYXJzZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0fW1zYClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvcGVuaW5nVG9DbG9zaW5nQnJhY2tldCAoY2hhcikge1xuICAgIHBhcnNlJDEoKTtcbiAgICByZXR1cm4gb3BlblRvQ2xvc2UuZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NpbmdUb09wZW5pbmdCcmFja2V0IChjaGFyKSB7XG4gICAgcGFyc2UkMSgpO1xuICAgIHJldHVybiBjbG9zZVRvT3Blbi5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2Fub25pY2FsQnJhY2tldCAoY2hhcikge1xuICAgIHBhcnNlJDEoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICAvLyBMb2NhbCB0eXBlIGFsaWFzZXNcbiAgdmFyIFRZUEVfTCA9IFRZUEVTLkw7XG4gIHZhciBUWVBFX1IgPSBUWVBFUy5SO1xuICB2YXIgVFlQRV9FTiA9IFRZUEVTLkVOO1xuICB2YXIgVFlQRV9FUyA9IFRZUEVTLkVTO1xuICB2YXIgVFlQRV9FVCA9IFRZUEVTLkVUO1xuICB2YXIgVFlQRV9BTiA9IFRZUEVTLkFOO1xuICB2YXIgVFlQRV9DUyA9IFRZUEVTLkNTO1xuICB2YXIgVFlQRV9CID0gVFlQRVMuQjtcbiAgdmFyIFRZUEVfUyA9IFRZUEVTLlM7XG4gIHZhciBUWVBFX09OID0gVFlQRVMuT047XG4gIHZhciBUWVBFX0JOID0gVFlQRVMuQk47XG4gIHZhciBUWVBFX05TTSA9IFRZUEVTLk5TTTtcbiAgdmFyIFRZUEVfQUwgPSBUWVBFUy5BTDtcbiAgdmFyIFRZUEVfTFJPID0gVFlQRVMuTFJPO1xuICB2YXIgVFlQRV9STE8gPSBUWVBFUy5STE87XG4gIHZhciBUWVBFX0xSRSA9IFRZUEVTLkxSRTtcbiAgdmFyIFRZUEVfUkxFID0gVFlQRVMuUkxFO1xuICB2YXIgVFlQRV9QREYgPSBUWVBFUy5QREY7XG4gIHZhciBUWVBFX0xSSSA9IFRZUEVTLkxSSTtcbiAgdmFyIFRZUEVfUkxJID0gVFlQRVMuUkxJO1xuICB2YXIgVFlQRV9GU0kgPSBUWVBFUy5GU0k7XG4gIHZhciBUWVBFX1BESSA9IFRZUEVTLlBESTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gR2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7e3N0YXJ0LCBlbmQsIGxldmVsfVtdfSBwYXJhZ3JhcGhzXG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gbGV2ZWxzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIEJpZGlyZWN0aW9uYWwgQWxnb3JpdGhtIHRvIGEgc3RyaW5nLCByZXR1cm5pbmcgdGhlIHJlc29sdmVkIGVtYmVkZGluZyBsZXZlbHNcbiAgICogaW4gYSBzaW5nbGUgVWludDhBcnJheSBwbHVzIGEgbGlzdCBvZiBvYmplY3RzIGhvbGRpbmcgZWFjaCBwYXJhZ3JhcGgncyBzdGFydCBhbmQgZW5kIGluZGljZXMgYW5kIHJlc29sdmVkXG4gICAqIGJhc2UgZW1iZWRkaW5nIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIGlucHV0IHN0cmluZ1xuICAgKiBAcGFyYW0ge1wibHRyXCJ8XCJydGxcInxcImF1dG9cIn0gW2Jhc2VEaXJlY3Rpb25dIC0gVXNlIFwibHRyXCIgb3IgXCJydGxcIiB0byBmb3JjZSBhIGJhc2UgcGFyYWdyYXBoIGRpcmVjdGlvbixcbiAgICogICAgICAgIG90aGVyd2lzZSBhIGRpcmVjdGlvbiB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5IGZyb20gZWFjaCBwYXJhZ3JhcGgncyBjb250ZW50cy5cbiAgICogQHJldHVybiB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RW1iZWRkaW5nTGV2ZWxzIChzdHJpbmcsIGJhc2VEaXJlY3Rpb24pIHtcbiAgICB2YXIgTUFYX0RFUFRIID0gMTI1O1xuXG4gICAgLy8gU3RhcnQgYnkgbWFwcGluZyBhbGwgY2hhcmFjdGVycyB0byB0aGVpciB1bmljb2RlIHR5cGUsIGFzIGEgYml0bWFzayBpbnRlZ2VyXG4gICAgdmFyIGNoYXJUeXBlcyA9IG5ldyBVaW50MzJBcnJheShzdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhclR5cGVzW2ldID0gZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJUeXBlQ291bnRzID0gbmV3IE1hcCgpOyAvL3dpbGwgYmUgY2xlYXJlZCBhdCBzdGFydCBvZiBlYWNoIHBhcmFncmFwaFxuICAgIGZ1bmN0aW9uIGNoYW5nZUNoYXJUeXBlKGksIHR5cGUpIHtcbiAgICAgIHZhciBvbGRUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgY2hhclR5cGVzW2ldID0gdHlwZTtcbiAgICAgIGNoYXJUeXBlQ291bnRzLnNldChvbGRUeXBlLCBjaGFyVHlwZUNvdW50cy5nZXQob2xkVHlwZSkgLSAxKTtcbiAgICAgIGlmIChvbGRUeXBlICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChORVVUUkFMX0lTT0xBVEVfVFlQRVMsIGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpIC0gMSk7XG4gICAgICB9XG4gICAgICBjaGFyVHlwZUNvdW50cy5zZXQodHlwZSwgKGNoYXJUeXBlQ291bnRzLmdldCh0eXBlKSB8fCAwKSArIDEpO1xuICAgICAgaWYgKHR5cGUgJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHx8IDApICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVtYmVkTGV2ZWxzID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nLmxlbmd0aCk7XG4gICAgdmFyIGlzb2xhdGlvblBhaXJzID0gbmV3IE1hcCgpOyAvL2luaXQtPnBkaSBhbmQgcGRpLT5pbml0XG5cbiAgICAvLyA9PT0gMy4zLjEgVGhlIFBhcmFncmFwaCBMZXZlbCA9PT1cbiAgICAvLyAzLjMuMSBQMTogU3BsaXQgdGhlIHRleHQgaW50byBwYXJhZ3JhcGhzXG4gICAgdmFyIHBhcmFncmFwaHMgPSBbXTsgLy8gW3tzdGFydCwgZW5kLCBsZXZlbH0sIC4uLl1cbiAgICB2YXIgcGFyYWdyYXBoID0gbnVsbDtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzdHJpbmcubGVuZ3RoOyBpJDErKykge1xuICAgICAgaWYgKCFwYXJhZ3JhcGgpIHtcbiAgICAgICAgcGFyYWdyYXBocy5wdXNoKHBhcmFncmFwaCA9IHtcbiAgICAgICAgICBzdGFydDogaSQxLFxuICAgICAgICAgIGVuZDogc3RyaW5nLmxlbmd0aCAtIDEsXG4gICAgICAgICAgLy8gMy4zLjEgUDItUDM6IERldGVybWluZSB0aGUgcGFyYWdyYXBoIGxldmVsXG4gICAgICAgICAgbGV2ZWw6IGJhc2VEaXJlY3Rpb24gPT09ICdydGwnID8gMSA6IGJhc2VEaXJlY3Rpb24gPT09ICdsdHInID8gMCA6IGRldGVybWluZUF1dG9FbWJlZExldmVsKGkkMSwgZmFsc2UpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJUeXBlc1tpJDFdICYgVFlQRV9CKSB7XG4gICAgICAgIHBhcmFncmFwaC5lbmQgPSBpJDE7XG4gICAgICAgIHBhcmFncmFwaCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEZPUk1BVFRJTkdfVFlQRVMgPSBUWVBFX1JMRSB8IFRZUEVfTFJFIHwgVFlQRV9STE8gfCBUWVBFX0xSTyB8IElTT0xBVEVfSU5JVF9UWVBFUyB8IFRZUEVfUERJIHwgVFlQRV9QREYgfCBUWVBFX0I7XG4gICAgdmFyIG5leHRFdmVuID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gKyAoKG4gJiAxKSA/IDEgOiAyKTsgfTtcbiAgICB2YXIgbmV4dE9kZCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICsgKChuICYgMSkgPyAyIDogMSk7IH07XG5cbiAgICAvLyBFdmVyeXRoaW5nIGZyb20gaGVyZSBvbiB3aWxsIG9wZXJhdGUgcGVyIHBhcmFncmFwaC5cbiAgICBmb3IgKHZhciBwYXJhSWR4ID0gMDsgcGFyYUlkeCA8IHBhcmFncmFwaHMubGVuZ3RoOyBwYXJhSWR4KyspIHtcbiAgICAgIHBhcmFncmFwaCA9IHBhcmFncmFwaHNbcGFyYUlkeF07XG4gICAgICB2YXIgc3RhdHVzU3RhY2sgPSBbe1xuICAgICAgICBfbGV2ZWw6IHBhcmFncmFwaC5sZXZlbCxcbiAgICAgICAgX292ZXJyaWRlOiAwLCAvLzA9bmV1dHJhbCwgMT1MLCAyPVJcbiAgICAgICAgX2lzb2xhdGU6IDAgLy9ib29sXG4gICAgICB9XTtcbiAgICAgIHZhciBzdGFja1RvcCA9ICh2b2lkIDApO1xuICAgICAgdmFyIG92ZXJmbG93SXNvbGF0ZUNvdW50ID0gMDtcbiAgICAgIHZhciBvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID0gMDtcbiAgICAgIHZhciB2YWxpZElzb2xhdGVDb3VudCA9IDA7XG4gICAgICBjaGFyVHlwZUNvdW50cy5jbGVhcigpO1xuXG4gICAgICAvLyA9PT0gMy4zLjIgRXhwbGljaXQgTGV2ZWxzIGFuZCBEaXJlY3Rpb25zID09PVxuICAgICAgZm9yICh2YXIgaSQyID0gcGFyYWdyYXBoLnN0YXJ0OyBpJDIgPD0gcGFyYWdyYXBoLmVuZDsgaSQyKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlID0gY2hhclR5cGVzW2kkMl07XG4gICAgICAgIHN0YWNrVG9wID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gU2V0IGluaXRpYWwgY291bnRzXG4gICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChjaGFyVHlwZSwgKGNoYXJUeXBlQ291bnRzLmdldChjaGFyVHlwZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHx8IDApICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBsaWNpdCBFbWJlZGRpbmdzOiAzLjMuMiBYMiAtIFgzXG4gICAgICAgIGlmIChjaGFyVHlwZSAmIEZPUk1BVFRJTkdfVFlQRVMpIHsgLy9wcmVmaWx0ZXIgYWxsIGZvcm1hdHRlcnNcbiAgICAgICAgICBpZiAoY2hhclR5cGUgJiAoVFlQRV9STEUgfCBUWVBFX0xSRSkpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgICAgdmFyIGxldmVsID0gKGNoYXJUeXBlID09PSBUWVBFX1JMRSA/IG5leHRPZGQgOiBuZXh0RXZlbikoc3RhY2tUb3AuX2xldmVsKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8PSBNQVhfREVQVEggJiYgIW92ZXJmbG93SXNvbGF0ZUNvdW50ICYmICFvdmVyZmxvd0VtYmVkZGluZ0NvdW50KSB7XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgX292ZXJyaWRlOiAwLFxuICAgICAgICAgICAgICAgIF9pc29sYXRlOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3ZlcmZsb3dJc29sYXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4cGxpY2l0IE92ZXJyaWRlczogMy4zLjIgWDQgLSBYNVxuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgKFRZUEVfUkxPIHwgVFlQRV9MUk8pKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsOyAvLyA1LjJcbiAgICAgICAgICAgIHZhciBsZXZlbCQxID0gKGNoYXJUeXBlID09PSBUWVBFX1JMTyA/IG5leHRPZGQgOiBuZXh0RXZlbikoc3RhY2tUb3AuX2xldmVsKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCQxIDw9IE1BWF9ERVBUSCAmJiAhb3ZlcmZsb3dJc29sYXRlQ291bnQgJiYgIW92ZXJmbG93RW1iZWRkaW5nQ291bnQpIHtcbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgX2xldmVsOiBsZXZlbCQxLFxuICAgICAgICAgICAgICAgIF9vdmVycmlkZTogKGNoYXJUeXBlICYgVFlQRV9STE8pID8gVFlQRV9SIDogVFlQRV9MLFxuICAgICAgICAgICAgICAgIF9pc29sYXRlOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3ZlcmZsb3dJc29sYXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElzb2xhdGVzOiAzLjMuMiBYNWEgLSBYNWNcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgICAgLy8gWDVjIC0gRlNJIGJlY29tZXMgZWl0aGVyIFJMSSBvciBMUklcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZSAmIFRZUEVfRlNJKSB7XG4gICAgICAgICAgICAgIGNoYXJUeXBlID0gZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwoaSQyICsgMSwgdHJ1ZSkgPT09IDEgPyBUWVBFX1JMSSA6IFRZUEVfTFJJO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsO1xuICAgICAgICAgICAgaWYgKHN0YWNrVG9wLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGV2ZWwkMiA9IChjaGFyVHlwZSA9PT0gVFlQRV9STEkgPyBuZXh0T2RkIDogbmV4dEV2ZW4pKHN0YWNrVG9wLl9sZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwkMiA8PSBNQVhfREVQVEggJiYgb3ZlcmZsb3dJc29sYXRlQ291bnQgPT09IDAgJiYgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICB2YWxpZElzb2xhdGVDb3VudCsrO1xuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBfbGV2ZWw6IGxldmVsJDIsXG4gICAgICAgICAgICAgICAgX292ZXJyaWRlOiAwLFxuICAgICAgICAgICAgICAgIF9pc29sYXRlOiAxLFxuICAgICAgICAgICAgICAgIF9pc29sSW5pdEluZGV4OiBpJDJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdmVyZmxvd0lzb2xhdGVDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRlcm1pbmF0aW5nIElzb2xhdGVzOiAzLjMuMiBYNmFcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIFRZUEVfUERJKSB7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dJc29sYXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93SXNvbGF0ZUNvdW50LS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbGlkSXNvbGF0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKCFzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXS5faXNvbGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEFkZCB0byBpc29sYXRpb24gcGFpcnMgYmlkaXJlY3Rpb25hbCBtYXBwaW5nOlxuICAgICAgICAgICAgICB2YXIgaXNvbEluaXRJbmRleCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdLl9pc29sSW5pdEluZGV4O1xuICAgICAgICAgICAgICBpZiAoaXNvbEluaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXNvbGF0aW9uUGFpcnMuc2V0KGlzb2xJbml0SW5kZXgsIGkkMik7XG4gICAgICAgICAgICAgICAgaXNvbGF0aW9uUGFpcnMuc2V0KGkkMiwgaXNvbEluaXRJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIHZhbGlkSXNvbGF0ZUNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDtcbiAgICAgICAgICAgIGlmIChzdGFja1RvcC5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQyLCBzdGFja1RvcC5fb3ZlcnJpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgLy8gVGVybWluYXRpbmcgRW1iZWRkaW5ncyBhbmQgT3ZlcnJpZGVzOiAzLjMuMiBYN1xuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgVFlQRV9QREYpIHtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvd0lzb2xhdGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAob3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50LS07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YWNrVG9wLl9pc29sYXRlICYmIHN0YXR1c1N0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsOyAvLyA1LjJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFbmQgb2YgUGFyYWdyYXBoOiAzLjMuMiBYOFxuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgVFlQRV9CKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vbi1mb3JtYXR0aW5nIGNoYXJhY3RlcnM6IDMuMy4yIFg2XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7XG4gICAgICAgICAgLy8gTk9URTogVGhpcyBleGNsdXNpb24gb2YgQk4gc2VlbXMgdG8gZ28gYWdhaW5zdCB3aGF0IHNlY3Rpb24gNS4yIHNheXMsIGJ1dCBpcyByZXF1aXJlZCBmb3IgdGVzdCBwYXNzYWdlXG4gICAgICAgICAgaWYgKHN0YWNrVG9wLl9vdmVycmlkZSAmJiBjaGFyVHlwZSAhPT0gVFlQRV9CTikge1xuICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQyLCBzdGFja1RvcC5fb3ZlcnJpZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA9PT0gMy4zLjMgUHJlcGFyYXRpb25zIGZvciBJbXBsaWNpdCBQcm9jZXNzaW5nID09PVxuXG4gICAgICAvLyBSZW1vdmUgYWxsIFJMRSwgTFJFLCBSTE8sIExSTywgUERGLCBhbmQgQk4gY2hhcmFjdGVyczogMy4zLjMgWDlcbiAgICAgIC8vIE5vdGU6IER1ZSB0byBzZWN0aW9uIDUuMiwgd2Ugd29uJ3QgcmVtb3ZlIHRoZW0sIGJ1dCB3ZSdsbCB1c2UgdGhlIEJOX0xJS0VfVFlQRVMgYml0c2V0IHRvXG4gICAgICAvLyBlYXNpbHkgaWdub3JlIHRoZW0gYWxsIGZyb20gaGVyZSBvbiBvdXQuXG5cbiAgICAgIC8vIDMuMy4zIFgxMFxuICAgICAgLy8gQ29tcHV0ZSB0aGUgc2V0IG9mIGlzb2xhdGluZyBydW4gc2VxdWVuY2VzIGFzIHNwZWNpZmllZCBieSBCRDEzXG4gICAgICB2YXIgbGV2ZWxSdW5zID0gW107XG4gICAgICB2YXIgY3VycmVudFJ1biA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpJDMgPSBwYXJhZ3JhcGguc3RhcnQ7IGkkMyA8PSBwYXJhZ3JhcGguZW5kOyBpJDMrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUkMSA9IGNoYXJUeXBlc1tpJDNdO1xuICAgICAgICBpZiAoIShjaGFyVHlwZSQxICYgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICB2YXIgbHZsID0gZW1iZWRMZXZlbHNbaSQzXTtcbiAgICAgICAgICB2YXIgaXNJc29sSW5pdCA9IGNoYXJUeXBlJDEgJiBJU09MQVRFX0lOSVRfVFlQRVM7XG4gICAgICAgICAgdmFyIGlzUERJID0gY2hhclR5cGUkMSA9PT0gVFlQRV9QREk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRSdW4gJiYgbHZsID09PSBjdXJyZW50UnVuLl9sZXZlbCkge1xuICAgICAgICAgICAgY3VycmVudFJ1bi5fZW5kID0gaSQzO1xuICAgICAgICAgICAgY3VycmVudFJ1bi5fZW5kc1dpdGhJc29sSW5pdCA9IGlzSXNvbEluaXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsUnVucy5wdXNoKGN1cnJlbnRSdW4gPSB7XG4gICAgICAgICAgICAgIF9zdGFydDogaSQzLFxuICAgICAgICAgICAgICBfZW5kOiBpJDMsXG4gICAgICAgICAgICAgIF9sZXZlbDogbHZsLFxuICAgICAgICAgICAgICBfc3RhcnRzV2l0aFBESTogaXNQREksXG4gICAgICAgICAgICAgIF9lbmRzV2l0aElzb2xJbml0OiBpc0lzb2xJbml0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpc29sYXRpbmdSdW5TZXFzID0gW107IC8vIFt7c2VxSW5kaWNlczogW10sIHNvc1R5cGU6IEx8UiwgZW9zVHlwZTogTHxSfV1cbiAgICAgIGZvciAodmFyIHJ1bklkeCA9IDA7IHJ1bklkeCA8IGxldmVsUnVucy5sZW5ndGg7IHJ1bklkeCsrKSB7XG4gICAgICAgIHZhciBydW4gPSBsZXZlbFJ1bnNbcnVuSWR4XTtcbiAgICAgICAgaWYgKCFydW4uX3N0YXJ0c1dpdGhQREkgfHwgKHJ1bi5fc3RhcnRzV2l0aFBESSAmJiAhaXNvbGF0aW9uUGFpcnMuaGFzKHJ1bi5fc3RhcnQpKSkge1xuICAgICAgICAgIHZhciBzZXFSdW5zID0gW2N1cnJlbnRSdW4gPSBydW5dO1xuICAgICAgICAgIGZvciAodmFyIHBkaUluZGV4ID0gKHZvaWQgMCk7IGN1cnJlbnRSdW4gJiYgY3VycmVudFJ1bi5fZW5kc1dpdGhJc29sSW5pdCAmJiAocGRpSW5kZXggPSBpc29sYXRpb25QYWlycy5nZXQoY3VycmVudFJ1bi5fZW5kKSkgIT0gbnVsbDspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkkNCA9IHJ1bklkeCArIDE7IGkkNCA8IGxldmVsUnVucy5sZW5ndGg7IGkkNCsrKSB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbFJ1bnNbaSQ0XS5fc3RhcnQgPT09IHBkaUluZGV4KSB7XG4gICAgICAgICAgICAgICAgc2VxUnVucy5wdXNoKGN1cnJlbnRSdW4gPSBsZXZlbFJ1bnNbaSQ0XSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBidWlsZCBmbGF0IGxpc3Qgb2YgaW5kaWNlcyBhY3Jvc3MgYWxsIHJ1bnM6XG4gICAgICAgICAgdmFyIHNlcUluZGljZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBzZXFSdW5zLmxlbmd0aDsgaSQ1KyspIHtcbiAgICAgICAgICAgIHZhciBydW4kMSA9IHNlcVJ1bnNbaSQ1XTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBydW4kMS5fc3RhcnQ7IGogPD0gcnVuJDEuX2VuZDsgaisrKSB7XG4gICAgICAgICAgICAgIHNlcUluZGljZXMucHVzaChqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzb3MvZW9zIHR5cGVzOlxuICAgICAgICAgIHZhciBmaXJzdExldmVsID0gZW1iZWRMZXZlbHNbc2VxSW5kaWNlc1swXV07XG4gICAgICAgICAgdmFyIHByZXZMZXZlbCA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICBmb3IgKHZhciBpJDYgPSBzZXFJbmRpY2VzWzBdIC0gMTsgaSQ2ID49IDA7IGkkNi0tKSB7XG4gICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbaSQ2XSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgIHByZXZMZXZlbCA9IGVtYmVkTGV2ZWxzW2kkNl07XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBzZXFJbmRpY2VzW3NlcUluZGljZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIGxhc3RMZXZlbCA9IGVtYmVkTGV2ZWxzW2xhc3RJbmRleF07XG4gICAgICAgICAgdmFyIG5leHRMZXZlbCA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbbGFzdEluZGV4XSAmIElTT0xBVEVfSU5JVF9UWVBFUykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkkNyA9IGxhc3RJbmRleCArIDE7IGkkNyA8PSBwYXJhZ3JhcGguZW5kOyBpJDcrKykge1xuICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbaSQ3XSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgICAgbmV4dExldmVsID0gZW1iZWRMZXZlbHNbaSQ3XTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzb2xhdGluZ1J1blNlcXMucHVzaCh7XG4gICAgICAgICAgICBfc2VxSW5kaWNlczogc2VxSW5kaWNlcyxcbiAgICAgICAgICAgIF9zb3NUeXBlOiBNYXRoLm1heChwcmV2TGV2ZWwsIGZpcnN0TGV2ZWwpICUgMiA/IFRZUEVfUiA6IFRZUEVfTCxcbiAgICAgICAgICAgIF9lb3NUeXBlOiBNYXRoLm1heChuZXh0TGV2ZWwsIGxhc3RMZXZlbCkgJSAyID8gVFlQRV9SIDogVFlQRV9MXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIG5leHQgc3RlcHMgYXJlIGRvbmUgcGVyIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgIGZvciAodmFyIHNlcUlkeCA9IDA7IHNlcUlkeCA8IGlzb2xhdGluZ1J1blNlcXMubGVuZ3RoOyBzZXFJZHgrKykge1xuICAgICAgICB2YXIgcmVmID0gaXNvbGF0aW5nUnVuU2Vxc1tzZXFJZHhdO1xuICAgICAgICB2YXIgc2VxSW5kaWNlcyQxID0gcmVmLl9zZXFJbmRpY2VzO1xuICAgICAgICB2YXIgc29zVHlwZSA9IHJlZi5fc29zVHlwZTtcbiAgICAgICAgdmFyIGVvc1R5cGUgPSByZWYuX2Vvc1R5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgdGhlIGxldmVsIHJ1bnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSBoYXZlIHRoZSBzYW1lIGVtYmVkZGluZyBsZXZlbC5cbiAgICAgICAgICogXG4gICAgICAgICAqIERPIE5PVCBjaGFuZ2UgYW55IGBlbWJlZExldmVsc1tpXWAgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGVtYmVkRGlyZWN0aW9uID0gKChlbWJlZExldmVsc1tzZXFJbmRpY2VzJDFbMF1dKSAmIDEpID8gVFlQRV9SIDogVFlQRV9MO1xuXG4gICAgICAgIC8vID09PSAzLjMuNCBSZXNvbHZpbmcgV2VhayBUeXBlcyA9PT1cblxuICAgICAgICAvLyBXMSArIDUuMi4gU2VhcmNoIGJhY2t3YXJkIGZyb20gZWFjaCBOU00gdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSB3aG9zZVxuICAgICAgICAvLyBiaWRpcmVjdGlvbmFsIHR5cGUgaXMgbm90IEJOLCBhbmQgc2V0IHRoZSBOU00gdG8gT04gaWYgaXQgaXMgYW4gaXNvbGF0ZSBpbml0aWF0b3Igb3IgUERJLCBhbmQgdG8gaXRzXG4gICAgICAgIC8vIHR5cGUgb3RoZXJ3aXNlLiBJZiB0aGUgTlNNIGlzIHRoZSBmaXJzdCBub24tQk4gY2hhcmFjdGVyLCBjaGFuZ2UgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiBzb3MuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9OU00pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpKyspIHtcbiAgICAgICAgICAgIHZhciBpJDggPSBzZXFJbmRpY2VzJDFbc2ldO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDhdICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUeXBlID0gc29zVHlwZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2ogPSBzaSAtIDE7IHNqID49IDA7IHNqLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqXV0gJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMiBzY2FuIGJhY2sgdG8gZmlyc3Qgbm9uLUJOXG4gICAgICAgICAgICAgICAgICBwcmV2VHlwZSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2pdXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkOCwgKHByZXZUeXBlICYgKElTT0xBVEVfSU5JVF9UWVBFUyB8IFRZUEVfUERJKSkgPyBUWVBFX09OIDogcHJldlR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcylcbiAgICAgICAgLy8gaXMgZm91bmQuIElmIGFuIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWMgbnVtYmVyLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRU4pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkMSA9IDA7IHNpJDEgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxKyspIHtcbiAgICAgICAgICAgIHZhciBpJDkgPSBzZXFJbmRpY2VzJDFbc2kkMV07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkOV0gJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDEgPSBzaSQxIC0gMTsgc2okMSA+PSAtMTsgc2okMS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZDaGFyVHlwZSA9IHNqJDEgPT09IC0xID8gc29zVHlwZSA6IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okMV1dO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hhclR5cGUgJiBTVFJPTkdfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hhclR5cGUgPT09IFRZUEVfQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQ5LCBUWVBFX0FOKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFJcbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0FMKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDIgPSAwOyBzaSQyIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMisrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMCA9IHNlcUluZGljZXMkMVtzaSQyXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxMF0gJiBUWVBFX0FMKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTAsIFRZUEVfUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vblxuICAgICAgICAvLyBzZXBhcmF0b3IgYmV0d2VlbiB0d28gbnVtYmVycyBvZiB0aGUgc2FtZSB0eXBlIGNoYW5nZXMgdG8gdGhhdCB0eXBlLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVMpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0NTKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDMgPSAxOyBzaSQzIDwgc2VxSW5kaWNlcyQxLmxlbmd0aCAtIDE7IHNpJDMrKykge1xuICAgICAgICAgICAgdmFyIGkkMTEgPSBzZXFJbmRpY2VzJDFbc2kkM107XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTFdICYgKFRZUEVfRVMgfCBUWVBFX0NTKSkge1xuICAgICAgICAgICAgICB2YXIgcHJldlR5cGUkMSA9IDAsIG5leHRUeXBlID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okMiA9IHNpJDMgLSAxOyBzaiQyID49IDA7IHNqJDItLSkge1xuICAgICAgICAgICAgICAgIHByZXZUeXBlJDEgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDJdXTtcbiAgICAgICAgICAgICAgICBpZiAoIShwcmV2VHlwZSQxICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDMgPSBzaSQzICsgMTsgc2okMyA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNqJDMrKykge1xuICAgICAgICAgICAgICAgIG5leHRUeXBlID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQzXV07XG4gICAgICAgICAgICAgICAgaWYgKCEobmV4dFR5cGUgJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHByZXZUeXBlJDEgPT09IG5leHRUeXBlICYmIChjaGFyVHlwZXNbaSQxMV0gPT09IFRZUEVfRVMgPyBwcmV2VHlwZSQxID09PSBUWVBFX0VOIDogKHByZXZUeXBlJDEgJiAoVFlQRV9FTiB8IFRZUEVfQU4pKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDExLCBwcmV2VHlwZSQxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VOKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDQgPSAwOyBzaSQ0IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNCsrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMiA9IHNlcUluZGljZXMkMVtzaSQ0XTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxMl0gJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDQgPSBzaSQ0IC0gMTsgc2okNCA+PSAwICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDRdXSAmIChUWVBFX0VUIHwgQk5fTElLRV9UWVBFUykpOyBzaiQ0LS0pIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2okNF0sIFRZUEVfRU4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoc2kkNCsrOyBzaSQ0IDwgc2VxSW5kaWNlcyQxLmxlbmd0aCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQ0XV0gJiAoVFlQRV9FVCB8IEJOX0xJS0VfVFlQRVMgfCBUWVBFX0VOKSk7IHNpJDQrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDRdXSAhPT0gVFlQRV9FTikge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NpJDRdLCBUWVBFX0VOKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXIgTmV1dHJhbC5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VUKSB8fCBjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FUykgfHwgY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfQ1MpKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkNSA9IDA7IHNpJDUgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ1KyspIHtcbiAgICAgICAgICAgIHZhciBpJDEzID0gc2VxSW5kaWNlcyQxW3NpJDVdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDEzXSAmIChUWVBFX0VUIHwgVFlQRV9FUyB8IFRZUEVfQ1MpKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTMsIFRZUEVfT04pO1xuICAgICAgICAgICAgICAvLyA1LjIgdHJhbnNmb3JtIGFkamFjZW50IEJOcyB0b286XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDUgPSBzaSQ1IC0gMTsgc2okNSA+PSAwICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDVdXSAmIEJOX0xJS0VfVFlQRVMpOyBzaiQ1LS0pIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2okNV0sIFRZUEVfT04pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDYgPSBzaSQ1ICsgMTsgc2okNiA8IHNlcUluZGljZXMkMS5sZW5ndGggJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNl1dICYgQk5fTElLRV9UWVBFUyk7IHNqJDYrKykge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaiQ2XSwgVFlQRV9PTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlciB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcylcbiAgICAgICAgLy8gaXMgZm91bmQuIElmIGFuIEwgaXMgZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cbiAgICAgICAgLy8gTk9URTogaW1wbGVtZW50ZWQgaW4gc2luZ2xlIGZvcndhcmQgcGFzcyBmb3IgZWZmaWNpZW5jeVxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRU4pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkNiA9IDAsIHByZXZTdHJvbmdUeXBlID0gc29zVHlwZTsgc2kkNiA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDYrKykge1xuICAgICAgICAgICAgdmFyIGkkMTQgPSBzZXFJbmRpY2VzJDFbc2kkNl07XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoYXJUeXBlc1tpJDE0XTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgVFlQRV9FTikge1xuICAgICAgICAgICAgICBpZiAocHJldlN0cm9uZ1R5cGUgPT09IFRZUEVfTCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTQsIFRZUEVfTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAmIFNUUk9OR19UWVBFUykge1xuICAgICAgICAgICAgICBwcmV2U3Ryb25nVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPT09IDMuMy41IFJlc29sdmluZyBOZXV0cmFsIGFuZCBJc29sYXRlIEZvcm1hdHRpbmcgVHlwZXMgPT09XG5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpKSB7XG4gICAgICAgICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dFxuICAgICAgICAgIC8vIHBvc2l0aW9ucyBvZiB0aGUgb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpcyBzY29wZSwgYmlkaXJlY3Rpb25hbFxuICAgICAgICAgIC8vIHR5cGVzIEVOIGFuZCBBTiBhcmUgdHJlYXRlZCBhcyBSLlxuICAgICAgICAgIHZhciBSX1RZUEVTX0ZPUl9OX1NURVBTID0gKFRZUEVfUiB8IFRZUEVfRU4gfCBUWVBFX0FOKTtcbiAgICAgICAgICB2YXIgU1RST05HX1RZUEVTX0ZPUl9OX1NURVBTID0gUl9UWVBFU19GT1JfTl9TVEVQUyB8IFRZUEVfTDtcblxuICAgICAgICAgIC8vICogSWRlbnRpZnkgdGhlIGJyYWNrZXQgcGFpcnMgaW4gdGhlIGN1cnJlbnQgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gQkQxNi5cbiAgICAgICAgICB2YXIgYnJhY2tldFBhaXJzID0gW107XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG9wZW5lclN0YWNrID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBzaSQ3ID0gMDsgc2kkNyA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDcrKykge1xuICAgICAgICAgICAgICAvLyBOT1RFOiBmb3IgYW55IHBvdGVudGlhbCBicmFja2V0IGNoYXJhY3RlciB3ZSBhbHNvIHRlc3QgdGhhdCBpdCBzdGlsbCBjYXJyaWVzIGEgTklcbiAgICAgICAgICAgICAgLy8gdHlwZSwgYXMgdGhhdCBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgZWFybGllci4gVGhpcyBkb2Vzbid0IHNlZW0gdG8gYmUgZXhwbGljaXRseVxuICAgICAgICAgICAgICAvLyBjYWxsZWQgb3V0IGluIHRoZSBzcGVjLCBidXQgaXMgcmVxdWlyZWQgZm9yIHBhc3NhZ2Ugb2YgY2VydGFpbiB0ZXN0cy5cbiAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkN11dICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDddXTtcbiAgICAgICAgICAgICAgICB2YXIgb3Bwb3NpdGVCcmFja2V0ID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgLy8gT3BlbmluZyBicmFja2V0XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0KGNoYXIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob3BlbmVyU3RhY2subGVuZ3RoIDwgNjMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyU3RhY2sucHVzaCh7IGNoYXI6IGNoYXIsIHNlcUluZGV4OiBzaSQ3IH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG9wcG9zaXRlQnJhY2tldCA9IGNsb3NpbmdUb09wZW5pbmdCcmFja2V0KGNoYXIpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3RhY2tJZHggPSBvcGVuZXJTdGFjay5sZW5ndGggLSAxOyBzdGFja0lkeCA+PSAwOyBzdGFja0lkeC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFja0NoYXIgPSBvcGVuZXJTdGFja1tzdGFja0lkeF0uY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrQ2hhciA9PT0gb3Bwb3NpdGVCcmFja2V0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgc3RhY2tDaGFyID09PSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldChnZXRDYW5vbmljYWxCcmFja2V0KGNoYXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0KGdldENhbm9uaWNhbEJyYWNrZXQoc3RhY2tDaGFyKSkgPT09IGNoYXJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJhY2tldFBhaXJzLnB1c2goW29wZW5lclN0YWNrW3N0YWNrSWR4XS5zZXFJbmRleCwgc2kkN10pO1xuICAgICAgICAgICAgICAgICAgICAgIG9wZW5lclN0YWNrLmxlbmd0aCA9IHN0YWNrSWR4OyAvL3BvcCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBhbmQgYWxsIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyYWNrZXRQYWlycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vICogRm9yIGVhY2ggYnJhY2tldC1wYWlyIGVsZW1lbnQgaW4gdGhlIGxpc3Qgb2YgcGFpcnMgb2YgdGV4dCBwb3NpdGlvbnNcbiAgICAgICAgICBmb3IgKHZhciBwYWlySWR4ID0gMDsgcGFpcklkeCA8IGJyYWNrZXRQYWlycy5sZW5ndGg7IHBhaXJJZHgrKykge1xuICAgICAgICAgICAgdmFyIHJlZiQxID0gYnJhY2tldFBhaXJzW3BhaXJJZHhdO1xuICAgICAgICAgICAgdmFyIG9wZW5TZXFJZHggPSByZWYkMVswXTtcbiAgICAgICAgICAgIHZhciBjbG9zZVNlcUlkeCA9IHJlZiQxWzFdO1xuICAgICAgICAgICAgLy8gYS4gSW5zcGVjdCB0aGUgYmlkaXJlY3Rpb25hbCB0eXBlcyBvZiB0aGUgY2hhcmFjdGVycyBlbmNsb3NlZCB3aXRoaW4gdGhlIGJyYWNrZXQgcGFpci5cbiAgICAgICAgICAgIC8vIGIuIElmIGFueSBzdHJvbmcgdHlwZSAoZWl0aGVyIEwgb3IgUikgbWF0Y2hpbmcgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24gaXMgZm91bmQsIHNldCB0aGUgdHlwZSBmb3IgYm90aFxuICAgICAgICAgICAgLy8gYnJhY2tldHMgaW4gdGhlIHBhaXIgdG8gbWF0Y2ggdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAgICB2YXIgZm91bmRTdHJvbmdUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdXNlU3Ryb25nVHlwZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBzaSQ4ID0gb3BlblNlcUlkeCArIDE7IHNpJDggPCBjbG9zZVNlcUlkeDsgc2kkOCsrKSB7XG4gICAgICAgICAgICAgIHZhciBpJDE1ID0gc2VxSW5kaWNlcyQxW3NpJDhdO1xuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTVdICYgU1RST05HX1RZUEVTX0ZPUl9OX1NURVBTKSB7XG4gICAgICAgICAgICAgICAgZm91bmRTdHJvbmdUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbHIgPSAoY2hhclR5cGVzW2kkMTVdICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgaWYgKGxyID09PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGxyO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGMuIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgYSBzdHJvbmcgdHlwZSBpdCBtdXN0IGJlIG9wcG9zaXRlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLiBUaGVyZWZvcmUsIHRlc3RcbiAgICAgICAgICAgIC8vIGZvciBhbiBlc3RhYmxpc2hlZCBjb250ZXh0IHdpdGggYSBwcmVjZWRpbmcgc3Ryb25nIHR5cGUgYnkgY2hlY2tpbmcgYmFja3dhcmRzIGJlZm9yZSB0aGUgb3BlbmluZyBwYWlyZWRcbiAgICAgICAgICAgIC8vIGJyYWNrZXQgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChMLCBSLCBvciBzb3MpIGlzIGZvdW5kLlxuICAgICAgICAgICAgLy8gICAgMS4gSWYgdGhlIHByZWNlZGluZyBzdHJvbmcgdHlwZSBpcyBhbHNvIG9wcG9zaXRlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLCBjb250ZXh0IGlzIGVzdGFibGlzaGVkLCBzb1xuICAgICAgICAgICAgLy8gICAgc2V0IHRoZSB0eXBlIGZvciBib3RoIGJyYWNrZXRzIGluIHRoZSBwYWlyIHRvIHRoYXQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgLy8gICAgMi4gT3RoZXJ3aXNlIHNldCB0aGUgdHlwZSBmb3IgYm90aCBicmFja2V0cyBpbiB0aGUgcGFpciB0byB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIGlmIChmb3VuZFN0cm9uZ1R5cGUgJiYgIXVzZVN0cm9uZ1R5cGUpIHtcbiAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IHNvc1R5cGU7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNpJDkgPSBvcGVuU2VxSWR4IC0gMTsgc2kkOSA+PSAwOyBzaSQ5LS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaSQxNiA9IHNlcUluZGljZXMkMVtzaSQ5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTZdICYgU1RST05HX1RZUEVTX0ZPUl9OX1NURVBTKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbHIkMSA9IChjaGFyVHlwZXNbaSQxNl0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgIGlmIChsciQxICE9PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gbHIkMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBlbWJlZERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3Ryb25nVHlwZSkge1xuICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW29wZW5TZXFJZHhdXSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbY2xvc2VTZXFJZHhdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgIC8vICogQW55IG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgaGFkIG9yaWdpbmFsIGJpZGlyZWN0aW9uYWwgY2hhcmFjdGVyIHR5cGUgTlNNIHByaW9yIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgICAgICAvLyBvZiBXMSB0aGF0IGltbWVkaWF0ZWx5IGZvbGxvdyBhIHBhaXJlZCBicmFja2V0IHdoaWNoIGNoYW5nZWQgdG8gTCBvciBSIHVuZGVyIE4wIHNob3VsZCBjaGFuZ2UgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgLy8gdGhlIHR5cGUgb2YgdGhlaXIgcHJlY2VkaW5nIGJyYWNrZXQuXG4gICAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlICE9PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpJDEwID0gb3BlblNlcUlkeCArIDE7IHNpJDEwIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMTArKykge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMF1dICYgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDEwXV0pICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDEwXV0gPSB1c2VTdHJvbmdUeXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlICE9PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpJDExID0gY2xvc2VTZXFJZHggKyAxOyBzaSQxMSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDExKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTFdXSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW3NlcUluZGljZXMkMVtzaSQxMV1dKSAmIFRZUEVfTlNNKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMV1dID0gdXNlU3Ryb25nVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIE5JcyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGVcbiAgICAgICAgICAvLyBzYW1lIGRpcmVjdGlvbi5cbiAgICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBOSXMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICBmb3IgKHZhciBzaSQxMiA9IDA7IHNpJDEyIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMTIrKykge1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTJdXSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgICAgICB2YXIgbmlSdW5TdGFydCA9IHNpJDEyLCBuaVJ1bkVuZCA9IHNpJDEyO1xuICAgICAgICAgICAgICB2YXIgcHJldlR5cGUkMiA9IHNvc1R5cGU7IC8vc2kgPT09IDAgPyBzb3NUeXBlIDogKGNoYXJUeXBlc1tzZXFJbmRpY2VzW3NpIC0gMV1dICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0xcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2kyID0gc2kkMTIgLSAxOyBzaTIgPj0gMDsgc2kyLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTJdXSAmIEJOX0xJS0VfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICAgIG5pUnVuU3RhcnQgPSBzaTI7IC8vNS4yIHRyZWF0IEJOcyBhZGphY2VudCB0byBOSXMgYXMgTklzXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByZXZUeXBlJDIgPSAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTJdXSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG5leHRUeXBlJDEgPSBlb3NUeXBlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaTIkMSA9IHNpJDEyICsgMTsgc2kyJDEgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaTIkMSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyJDFdXSAmIChORVVUUkFMX0lTT0xBVEVfVFlQRVMgfCBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgICAgICAgICAgbmlSdW5FbmQgPSBzaTIkMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmV4dFR5cGUkMSA9IChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMiQxXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDcgPSBuaVJ1blN0YXJ0OyBzaiQ3IDw9IG5pUnVuRW5kOyBzaiQ3KyspIHtcbiAgICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDddXSA9IHByZXZUeXBlJDIgPT09IG5leHRUeXBlJDEgPyBwcmV2VHlwZSQyIDogZW1iZWREaXJlY3Rpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2kkMTIgPSBuaVJ1bkVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gPT09IDMuMy42IFJlc29sdmluZyBJbXBsaWNpdCBMZXZlbHMgPT09XG5cbiAgICAgIGZvciAodmFyIGkkMTcgPSBwYXJhZ3JhcGguc3RhcnQ7IGkkMTcgPD0gcGFyYWdyYXBoLmVuZDsgaSQxNysrKSB7XG4gICAgICAgIHZhciBsZXZlbCQzID0gZW1iZWRMZXZlbHNbaSQxN107XG4gICAgICAgIHZhciB0eXBlJDEgPSBjaGFyVHlwZXNbaSQxN107XG4gICAgICAgIC8vIEkyLiBGb3IgYWxsIGNoYXJhY3RlcnMgd2l0aCBhbiBvZGQgKHJpZ2h0LXRvLWxlZnQpIGVtYmVkZGluZyBsZXZlbCwgdGhvc2Ugb2YgdHlwZSBMLCBFTiBvciBBTiBnbyB1cCBvbmUgbGV2ZWwuXG4gICAgICAgIGlmIChsZXZlbCQzICYgMSkge1xuICAgICAgICAgIGlmICh0eXBlJDEgJiAoVFlQRV9MIHwgVFlQRV9FTiB8IFRZUEVfQU4pKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAgIC8vIEkxLiBGb3IgYWxsIGNoYXJhY3RlcnMgd2l0aCBhbiBldmVuIChsZWZ0LXRvLXJpZ2h0KSBlbWJlZGRpbmcgbGV2ZWwsIHRob3NlIG9mIHR5cGUgUiBnbyB1cCBvbmUgbGV2ZWxcbiAgICAgICAgLy8gYW5kIHRob3NlIG9mIHR5cGUgQU4gb3IgRU4gZ28gdXAgdHdvIGxldmVscy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGUkMSAmIFRZUEVfUikge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10rKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUkMSAmIChUWVBFX0FOIHwgVFlQRV9FTikpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4yOiBSZXNvbHZlIGFueSBMUkUsIFJMRSwgTFJPLCBSTE8sIFBERiwgb3IgQk4gdG8gdGhlIGxldmVsIG9mIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyIGlmIHRoZXJlIGlzIG9uZSxcbiAgICAgICAgLy8gYW5kIG90aGVyd2lzZSB0byB0aGUgYmFzZSBsZXZlbC5cbiAgICAgICAgaWYgKHR5cGUkMSAmIEJOX0xJS0VfVFlQRVMpIHtcbiAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSA9IGkkMTcgPT09IDAgPyBwYXJhZ3JhcGgubGV2ZWwgOiBlbWJlZExldmVsc1tpJDE3IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLjQgTDEuMS00OiBSZXNldCB0aGUgZW1iZWRkaW5nIGxldmVsIG9mIHNlZ21lbnQvcGFyYWdyYXBoIHNlcGFyYXRvcnMsIGFuZCBhbnkgc2VxdWVuY2Ugb2Ygd2hpdGVzcGFjZSBvclxuICAgICAgICAvLyBpc29sYXRlIGZvcm1hdHRpbmcgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlbSBvciB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGgsIHRvIHRoZSBwYXJhZ3JhcGggbGV2ZWwuXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgd2lsbCBhbHNvIG5lZWQgdG8gYmUgYXBwbGllZCB0byBlYWNoIGluZGl2aWR1YWwgbGluZSBlbmRpbmcgYWZ0ZXIgbGluZSB3cmFwcGluZyBvY2N1cnMuXG4gICAgICAgIGlmIChpJDE3ID09PSBwYXJhZ3JhcGguZW5kIHx8IGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaSQxN10pICYgKFRZUEVfUyB8IFRZUEVfQikpIHtcbiAgICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDE3OyBqJDEgPj0gMCAmJiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tqJDFdKSAmIFRSQUlMSU5HX1RZUEVTKTsgaiQxLS0pIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2okMV0gPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRE9ORSEgVGhlIHJlc29sdmVkIGxldmVscyBjYW4gdGhlbiBiZSB1c2VkLCBhZnRlciBsaW5lIHdyYXBwaW5nLCB0byBmbGlwIHJ1bnMgb2YgY2hhcmFjdGVyc1xuICAgIC8vIGFjY29yZGluZyB0byBzZWN0aW9uIDMuNCBSZW9yZGVyaW5nIFJlc29sdmVkIExldmVsc1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbHM6IGVtYmVkTGV2ZWxzLFxuICAgICAgcGFyYWdyYXBoczogcGFyYWdyYXBoc1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVybWluZUF1dG9FbWJlZExldmVsIChzdGFydCwgaXNGU0kpIHtcbiAgICAgIC8vIDMuMy4xIFAyIC0gUDNcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUgPSBjaGFyVHlwZXNbaV07XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIChUWVBFX1IgfCBUWVBFX0FMKSkge1xuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFyVHlwZSAmIChUWVBFX0IgfCBUWVBFX0wpKSB8fCAoaXNGU0kgJiYgY2hhclR5cGUgPT09IFRZUEVfUERJKSkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJUeXBlICYgSVNPTEFURV9JTklUX1RZUEVTKSB7XG4gICAgICAgICAgdmFyIHBkaSA9IGluZGV4T2ZNYXRjaGluZ1BESShpKTtcbiAgICAgICAgICBpID0gcGRpID09PSAtMSA/IHN0cmluZy5sZW5ndGggOiBwZGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXhPZk1hdGNoaW5nUERJIChpc29sYXRlU3RhcnQpIHtcbiAgICAgIC8vIDMuMS4yIEJEOVxuICAgICAgdmFyIGlzb2xhdGlvbkxldmVsID0gMTtcbiAgICAgIGZvciAodmFyIGkgPSBpc29sYXRlU3RhcnQgKyAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSA9IGNoYXJUeXBlc1tpXTtcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9CKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhclR5cGUgJiBUWVBFX1BESSkge1xuICAgICAgICAgIGlmICgtLWlzb2xhdGlvbkxldmVsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgIGlzb2xhdGlvbkxldmVsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgfVxuXG4gIC8vIEJpZGkgbWlycm9yZWQgY2hhcnMgZGF0YSwgYXV0byBnZW5lcmF0ZWRcbiAgdmFyIGRhdGEgPSBcIjE0PjEsaj4yLHQ+Mix1PjIsMWE+ZywydjM+MSwxPjEsMWdlPjEsMXdkPjEsYj4xLDFqPjEsZj4xLGFpPjMsLTI+MywrMSw4PjFrMCwtMWpxPjF5NywtMXk2PjFoZiwtMWhlPjFoNiwtMWg1PjFoYSwtMWg4PjFxaSwtMXB1PjEsNj4zdSwtM3M+Nyw2PjEsMT4xLGY+MSwxPjEsKzIsMz4xLDE+MSwrMTMsND4xLDE+MSw2PjFlbywtMWVlPjEsMz4xbWcsLTFtZT4xbWssLTFtaj4xbWksLTFtZz4xbWksLTFtZD4xLDE+MSwrMiwxPjEwaywtMTAzPjEsMT4xLDQ+MSw1PjEsMT4xLCsxMCwzPjEsMT44LC03PjgsKzEsLTY+NywrMSxhPjEsMT4xLHU+MSx1Nj4xLDE+MSwrNSwyNj4xLDE+MSwyPjEsMj4yLDg+MSw3PjEsND4xLDE+MSwrNSxiOD4xLDE+MSwrMywxPjMsLTI+MSwyPjEsMT4xLCsyLGM+MSwzPjEsMT4xLCsyLGg+MSwzPjEsYT4xLDE+MSwyPjEsMz4xLDE+MSxkPjEsZj4xLDM+MSwxYT4xLDE+MSw2PjEsNz4xLDEzPjEsaz4xLDE+MSwrMTksND4xLDE+MSwrMiwyPjEsMT4xLCsxOCxtPjEsYT4xLDE+MSxsaz4xLDE+MSw0PjEsMj4xLGY+MSwzPjEsMT4xLCszLGRiPjEsMT4xLCszLDM+MSwxPjEsKzIsMTRxbT4xLDE+MSwrMSw2PjEsNGo+MSxqPjIsdD4yLHU+MiwyPjEsKzFcIjtcblxuICB2YXIgbWlycm9yTWFwO1xuXG4gIGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICBpZiAoIW1pcnJvck1hcCkge1xuICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB2YXIgcmVmID0gcGFyc2VDaGFyYWN0ZXJNYXAoZGF0YSwgdHJ1ZSk7XG4gICAgICB2YXIgbWFwID0gcmVmLm1hcDtcbiAgICAgIHZhciByZXZlcnNlTWFwID0gcmVmLnJldmVyc2VNYXA7XG4gICAgICAvLyBDb21iaW5lIGJvdGggbWFwcyBpbnRvIG9uZVxuICAgICAgcmV2ZXJzZU1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIG1pcnJvck1hcCA9IG1hcDtcbiAgICAgIC8vY29uc29sZS5sb2coYG1pcnJvcmVkIGNoYXJzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pcnJvcmVkQ2hhcmFjdGVyIChjaGFyKSB7XG4gICAgcGFyc2UoKTtcbiAgICByZXR1cm4gbWlycm9yTWFwLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBzdHJpbmcgYW5kIGl0cyByZXNvbHZlZCBlbWJlZGRpbmcgbGV2ZWxzLCBidWlsZCBhIG1hcCBvZiBpbmRpY2VzIHRvIHJlcGxhY2VtZW50IGNoYXJzXG4gICAqIGZvciBhbnkgY2hhcmFjdGVycyBpbiByaWdodC10by1sZWZ0IHNlZ21lbnRzIHRoYXQgaGF2ZSBkZWZpbmVkIG1pcnJvcmVkIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBzdHJpbmdcbiAgICogQHBhcmFtIGVtYmVkZGluZ0xldmVsc1xuICAgKiBAcGFyYW0gW3N0YXJ0XVxuICAgKiBAcGFyYW0gW2VuZF1cbiAgICogQHJldHVybiB7TWFwPG51bWJlciwgc3RyaW5nPn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE1pcnJvcmVkQ2hhcmFjdGVyc01hcChzdHJpbmcsIGVtYmVkZGluZ0xldmVscywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgPT0gbnVsbCA/IDAgOiArc3RhcnQpO1xuICAgIGVuZCA9IE1hdGgubWluKHN0ckxlbiAtIDEsIGVuZCA9PSBudWxsID8gc3RyTGVuIC0gMSA6ICtlbmQpO1xuXG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIGlmIChlbWJlZGRpbmdMZXZlbHNbaV0gJiAxKSB7IC8vb25seSBvZGQgKHJ0bCkgbGV2ZWxzXG4gICAgICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3JlZENoYXJhY3RlcihzdHJpbmdbaV0pO1xuICAgICAgICBpZiAobWlycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgbWFwLnNldChpLCBtaXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHN0YXJ0IGFuZCBlbmQgZGVub3RpbmcgYSBzaW5nbGUgbGluZSB3aXRoaW4gYSBzdHJpbmcsIGFuZCBhIHNldCBvZiBwcmVjYWxjdWxhdGVkXG4gICAqIGJpZGkgZW1iZWRkaW5nIGxldmVscywgcHJvZHVjZSBhIGxpc3Qgb2Ygc2VnbWVudHMgd2hvc2Ugb3JkZXJpbmcgc2hvdWxkIGJlIGZsaXBwZWQsIGluIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gdGhlIGZ1bGwgaW5wdXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZGRpbmdMZXZlbHNSZXN1bHQgLSB0aGUgcmVzdWx0IG9iamVjdCBmcm9tIGdldEVtYmVkZGluZ0xldmVsc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XSAtIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN1YnNldCBvZiB0aGUgZnVsbCBzdHJpbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gbGFzdCBjaGFyYWN0ZXIgaW4gYSBzdWJzZXQgb2YgdGhlIGZ1bGwgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcltdW119IC0gdGhlIGxpc3Qgb2Ygc3RhcnQvZW5kIHNlZ21lbnRzIHRoYXQgc2hvdWxkIGJlIGZsaXBwZWQsIGluIG9yZGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVvcmRlclNlZ21lbnRzKHN0cmluZywgZW1iZWRkaW5nTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCA9PSBudWxsID8gMCA6ICtzdGFydCk7XG4gICAgZW5kID0gTWF0aC5taW4oc3RyTGVuIC0gMSwgZW5kID09IG51bGwgPyBzdHJMZW4gLSAxIDogK2VuZCk7XG5cbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICBlbWJlZGRpbmdMZXZlbHNSZXN1bHQucGFyYWdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhZ3JhcGgpIHtcbiAgICAgIHZhciBsaW5lU3RhcnQgPSBNYXRoLm1heChzdGFydCwgcGFyYWdyYXBoLnN0YXJ0KTtcbiAgICAgIHZhciBsaW5lRW5kID0gTWF0aC5taW4oZW5kLCBwYXJhZ3JhcGguZW5kKTtcbiAgICAgIGlmIChsaW5lU3RhcnQgPCBsaW5lRW5kKSB7XG4gICAgICAgIC8vIExvY2FsIHNsaWNlIGZvciBtdXRhdGlvblxuICAgICAgICB2YXIgbGluZUxldmVscyA9IGVtYmVkZGluZ0xldmVsc1Jlc3VsdC5sZXZlbHMuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG5cbiAgICAgICAgLy8gMy40IEwxLjQ6IFJlc2V0IGFueSBzZXF1ZW5jZSBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgYW5kL29yIGlzb2xhdGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIGF0IHRoZVxuICAgICAgICAvLyBlbmQgb2YgdGhlIGxpbmUgdG8gdGhlIHBhcmFncmFwaCBsZXZlbC5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxpbmVFbmQ7IGkgPj0gbGluZVN0YXJ0ICYmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2ldKSAmIFRSQUlMSU5HX1RZUEVTKTsgaS0tKSB7XG4gICAgICAgICAgbGluZUxldmVsc1tpXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEwyLiBGcm9tIHRoZSBoaWdoZXN0IGxldmVsIGZvdW5kIGluIHRoZSB0ZXh0IHRvIHRoZSBsb3dlc3Qgb2RkIGxldmVsIG9uIGVhY2ggbGluZSwgaW5jbHVkaW5nIGludGVybWVkaWF0ZSBsZXZlbHNcbiAgICAgICAgLy8gbm90IGFjdHVhbGx5IHByZXNlbnQgaW4gdGhlIHRleHQsIHJldmVyc2UgYW55IGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBhdCB0aGF0IGxldmVsIG9yIGhpZ2hlci5cbiAgICAgICAgdmFyIG1heExldmVsID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICB2YXIgbWluT2RkTGV2ZWwgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGluZUxldmVscy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gbGluZUxldmVsc1tpJDFdO1xuICAgICAgICAgIGlmIChsZXZlbCA+IG1heExldmVsKSB7IG1heExldmVsID0gbGV2ZWw7IH1cbiAgICAgICAgICBpZiAobGV2ZWwgPCBtaW5PZGRMZXZlbCkgeyBtaW5PZGRMZXZlbCA9IGxldmVsIHwgMTsgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGx2bCA9IG1heExldmVsOyBsdmwgPj0gbWluT2RkTGV2ZWw7IGx2bC0tKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbGluZUxldmVscy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICBpZiAobGluZUxldmVsc1tpJDJdID49IGx2bCkge1xuICAgICAgICAgICAgICB2YXIgc2VnU3RhcnQgPSBpJDI7XG4gICAgICAgICAgICAgIHdoaWxlIChpJDIgKyAxIDwgbGluZUxldmVscy5sZW5ndGggJiYgbGluZUxldmVsc1tpJDIgKyAxXSA+PSBsdmwpIHtcbiAgICAgICAgICAgICAgICBpJDIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaSQyID4gc2VnU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKFtzZWdTdGFydCArIGxpbmVTdGFydCwgaSQyICsgbGluZVN0YXJ0XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VnbWVudHNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZExldmVsc1Jlc3VsdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgbmV3IHN0cmluZyB3aXRoIGJpZGkgc2VnbWVudHMgcmVvcmRlcmVkXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZW9yZGVyZWRTdHJpbmcoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBpbmRpY2VzID0gZ2V0UmVvcmRlcmVkSW5kaWNlcyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKTtcbiAgICB2YXIgY2hhcnMgPSBbXS5jb25jYXQoIHN0cmluZyApO1xuICAgIGluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhckluZGV4LCBpKSB7XG4gICAgICBjaGFyc1tpXSA9IChcbiAgICAgICAgKGVtYmVkTGV2ZWxzUmVzdWx0LmxldmVsc1tjaGFySW5kZXhdICYgMSkgPyBnZXRNaXJyb3JlZENoYXJhY3RlcihzdHJpbmdbY2hhckluZGV4XSkgOiBudWxsXG4gICAgICApIHx8IHN0cmluZ1tjaGFySW5kZXhdO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9IGVtYmVkTGV2ZWxzUmVzdWx0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gYW4gYXJyYXkgd2l0aCBjaGFyYWN0ZXIgaW5kaWNlcyBpbiB0aGVpciBuZXcgYmlkaSBvcmRlclxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVvcmRlcmVkSW5kaWNlcyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gZ2V0UmVvcmRlclNlZ21lbnRzKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpO1xuICAgIC8vIEZpbGwgYW4gYXJyYXkgd2l0aCBpbmRpY2VzXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kaWNlc1tpXSA9IGk7XG4gICAgfVxuICAgIC8vIFJldmVyc2UgZWFjaCBzZWdtZW50IGluIG9yZGVyXG4gICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgc3RhcnQgPSByZWZbMF07XG4gICAgICB2YXIgZW5kID0gcmVmWzFdO1xuXG4gICAgICB2YXIgc2xpY2UgPSBpbmRpY2VzLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSBzbGljZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgaW5kaWNlc1tlbmQgLSBpXSA9IHNsaWNlW2ldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbmRpY2VzXG4gIH1cblxuICBleHBvcnRzLmNsb3NpbmdUb09wZW5pbmdCcmFja2V0ID0gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQ7XG4gIGV4cG9ydHMuZ2V0QmlkaUNoYXJUeXBlID0gZ2V0QmlkaUNoYXJUeXBlO1xuICBleHBvcnRzLmdldEJpZGlDaGFyVHlwZU5hbWUgPSBnZXRCaWRpQ2hhclR5cGVOYW1lO1xuICBleHBvcnRzLmdldENhbm9uaWNhbEJyYWNrZXQgPSBnZXRDYW5vbmljYWxCcmFja2V0O1xuICBleHBvcnRzLmdldEVtYmVkZGluZ0xldmVscyA9IGdldEVtYmVkZGluZ0xldmVscztcbiAgZXhwb3J0cy5nZXRNaXJyb3JlZENoYXJhY3RlciA9IGdldE1pcnJvcmVkQ2hhcmFjdGVyO1xuICBleHBvcnRzLmdldE1pcnJvcmVkQ2hhcmFjdGVyc01hcCA9IGdldE1pcnJvcmVkQ2hhcmFjdGVyc01hcDtcbiAgZXhwb3J0cy5nZXRSZW9yZGVyU2VnbWVudHMgPSBnZXRSZW9yZGVyU2VnbWVudHM7XG4gIGV4cG9ydHMuZ2V0UmVvcmRlcmVkSW5kaWNlcyA9IGdldFJlb3JkZXJlZEluZGljZXM7XG4gIGV4cG9ydHMuZ2V0UmVvcmRlcmVkU3RyaW5nID0gZ2V0UmVvcmRlcmVkU3RyaW5nO1xuICBleHBvcnRzLm9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0ID0gb3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSh7fSkpO1xucmV0dXJuIGJpZGl9XG5cbmV4cG9ydCBkZWZhdWx0IGJpZGlGYWN0b3J5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bidi-js/dist/bidi.mjs\n");

/***/ })

};
;